import { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport Redis from 'ioredis';\nimport LRU from 'lru-cache';\nimport crypto from 'crypto';\n\nexport interface CacheConfig {\n  redisUrl?: string;\n  maxMemoryItems?: number;\n  defaultTTL?: number; // in seconds\n  enableCompression?: boolean;\n  enableDistribution?: boolean;\n  keyPrefix?: string;\n  serializer?: 'json' | 'msgpack' | 'custom';\n  compressionThreshold?: number; // bytes\n}\n\nexport interface CacheOptions {\n  ttl?: number; // Time to live in seconds\n  tags?: string[]; // For cache invalidation\n  version?: string; // For versioned caching\n  compress?: boolean;\n  serialize?: boolean;\n  namespace?: string;\n  priority?: 'low' | 'normal' | 'high' | 'critical';\n}\n\nexport interface CacheEntry<T = any> {\n  key: string;\n  value: T;\n  ttl: number;\n  createdAt: Date;\n  expiresAt: Date;\n  lastAccessed: Date;\n  accessCount: number;\n  tags: string[];\n  version?: string;\n  namespace?: string;\n  priority: 'low' | 'normal' | 'high' | 'critical';\n  size: number; // in bytes\n  compressed: boolean;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface CacheStats {\n  hits: number;\n  misses: number;\n  hitRate: number;\n  totalItems: number;\n  memoryUsage: number;\n  redisUsage?: number;\n  evictions: number;\n  compressionRatio?: number;\n  averageItemSize: number;\n  operationsPerSecond: number;\n  distributedInvalidations: number;\n}\n\nexport interface CacheKeyPattern {\n  pattern: string;\n  ttl: number;\n  tags: string[];\n  priority: 'low' | 'normal' | 'high' | 'critical';\n  compress?: boolean;\n}\n\nexport interface CacheInvalidationRule {\n  id: string;\n  name: string;\n  triggers: CacheInvalidationTrigger[];\n  targets: CacheInvalidationTarget[];\n  isActive: boolean;\n  createdAt: Date;\n  lastTriggered?: Date;\n  triggerCount: number;\n}\n\nexport interface CacheInvalidationTrigger {\n  type: 'time' | 'event' | 'dependency' | 'manual';\n  condition: unknown;\n  schedule?: string; // cron expression for time-based\n  eventType?: string; // for event-based\n  dependencies?: string[]; // for dependency-based\n}\n\nexport interface CacheInvalidationTarget {\n  type: 'key' | 'pattern' | 'tag' | 'namespace';\n  value: string;\n  cascade?: boolean; // whether to invalidate dependent caches\n}\n\nclass CacheService extends EventEmitter {\n  private redis?: Redis;\n  private memoryCache: LRU<string, CacheEntry>;\n  private config: Required<CacheConfig>;\n  private stats: CacheStats;\n  private keyPatterns: Map<string, CacheKeyPattern> = new Map();\n  private invalidationRules: Map<string, CacheInvalidationRule> = new Map();\n  private compressionEnabled: boolean;\n  private compressionThreshold: number;\n  private nodeId: string;\n  private operationCounter = 0;\n  private operationStartTime = crypto.getRandomValues(new Uint32Array(1))[0];\n  \n  constructor(config: CacheConfig = {}) {\n    super();\n    \n    this.config = {\n      redisUrl: config.redisUrl || 'redis://localhost:6379',\n      maxMemoryItems: config.maxMemoryItems || 10000,\n      defaultTTL: config.defaultTTL || 3600, // 1 hour\n      enableCompression: config.enableCompression ?? true,\n      enableDistribution: config.enableDistribution ?? true,\n      keyPrefix: config.keyPrefix || 'hms:cache:',\n      serializer: config.serializer || 'json',\n      compressionThreshold: config.compressionThreshold || 1024 // 1KB\n    };\n    \n    this.compressionEnabled = this.config.enableCompression;\n    this.compressionThreshold = this.config.compressionThreshold;\n    this.nodeId = uuidv4();\n    \n    // Initialize memory cache\n    this.memoryCache = new LRU({\n      max: this.config.maxMemoryItems,\n      dispose: (key, entry) => {\n        this.stats.evictions++;\n        this.emit('cache_eviction', { key, entry });\n      },\n      updateAgeOnGet: true\n    });\n    \n    // Initialize stats\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      hitRate: 0,\n      totalItems: 0,\n      memoryUsage: 0,\n      evictions: 0,\n      averageItemSize: 0,\n      operationsPerSecond: 0,\n      distributedInvalidations: 0\n    };\n    \n    // Initialize Redis if enabled\n    \1 {\n  \2{\n      this.initializeRedis();\n    }\n    \n    // Initialize default cache patterns\n    this.initializeDefaultPatterns();\n    \n    // Start periodic cleanup and stats update\n    setInterval(() => this.updateStats(), 60000); // Every minute\n    setInterval(() => this.cleanup(), 300000); // Every 5 minutes\n  }\n\n  /**\n   * Get value from cache\n   */\n  async get<T = any>(key: string, options: Partial<CacheOptions> = {}): Promise<T | null> {\n    const fullKey = this.buildKey(key, options.namespace);\n    \n    try {\n      // Try memory cache first\n      const memoryEntry = this.memoryCache.get(fullKey);\n      \1 {\n  \2 {\n        memoryEntry.lastAccessed = new Date();\n        memoryEntry.accessCount++;\n        this.stats.hits++;\n        this.operationCounter++;\n        \n        this.emit('cache_hit', key: fullKey, source: 'memory', entry: memoryEntry );\n        return memoryEntry.value as T;\n      }\n      \n      // Try Redis cache\n      \1 {\n  \2{\n        const redisValue = await this.redis.get(fullKey);\n        \1 {\n  \2{\n          const entry = await this.deserializeEntry(redisValue);\n          \1 {\n  \2 {\n            // Store in memory cache for faster access\n            entry.lastAccessed = new Date();\n            entry.accessCount++;\n            this.memoryCache.set(fullKey, entry);\n            \n            this.stats.hits++;\n            this.operationCounter++;\n            \n            this.emit('cache_hit', { key: fullKey, source: 'redis', entry });\n            return entry.value as T;\n          }\n        }\n      }\n      \n      // Cache miss\n      this.stats.misses++;\n      this.operationCounter++;\n      this.emit('cache_miss', { key: fullKey });\n      \n      return null;\n    } catch (error) {\n      // Debug logging removed\n      this.emit('cache_error', { operation: 'get', key: fullKey, error });\n      return null;\n    }\n  }\n\n  /**\n   * Set value in cache\n   */\n  async set<T = any>(;\n    key: string, \n    value: T, \n    options: CacheOptions = {}\n  ): Promise<boolean> {\n    const fullKey = this.buildKey(key, options.namespace);\n    \n    try {\n      const ttl = options.ttl || this.config.defaultTTL;\n      const priority = options.priority || 'normal';\n      const tags = options.tags || [];\n      const compress = options.compress ?? this.shouldCompress(value);\n      \n      // Apply cache pattern if exists\n      const pattern = this.findMatchingPattern(key);\n      \1 {\n  \2{\n        options.ttl = pattern.ttl;\n        options.tags = [...tags, ...pattern.tags];\n        options.priority = pattern.priority;\n        options.compress = pattern.compress ?? compress;\n      }\n      \n      const entry: CacheEntry<T> = {\n        key: fullKey,\n        value,\n        ttl,\n        createdAt: new Date(),\n        expiresAt: new Date(crypto.getRandomValues(new Uint32Array(1))[0] + ttl * 1000),\n        lastAccessed: new Date(),\n        accessCount: 0,\n        tags: options.tags || [],\n        version: options.version,\n        namespace: options.namespace,\n        priority,\n        size: this.calculateSize(value),\n        compressed: compress,\n        metadata: {}\n      };\n      \n      // Compress if needed\n      \1 {\n  \2{\n        entry.value = await this.compress(value) as T;\n      }\n      \n      // Store in memory cache\n      this.memoryCache.set(fullKey, entry);\n      \n      // Store in Redis if enabled\n      \1 {\n  \2{\n        const serialized = await this.serializeEntry(entry);\n        await this.redis.setex(fullKey, ttl, serialized);\n        \n        // Store tags for invalidation\n        \1 {\n  \2{\n          await this.storeTagMappings(fullKey, tags);\n        }\n      }\n      \n      this.operationCounter++;\n      this.emit('cache_set', { key: fullKey, entry });\n      \n      return true;\n    } catch (error) {\n      // Debug logging removed\n      this.emit('cache_error', { operation: 'set', key: fullKey, error });\n      return false;\n    }\n  }\n\n  /**\n   * Get or set pattern - get value, or compute and cache if not found\n   */\n  async getOrSet<T = any>(;\n    key: string,\n    factory: () => Promise<T> | T,\n    options: CacheOptions = {}\n  ): Promise<T> {\n    const cached = await this.get<T>(key, options);\n    \1 {\n  \2{\n      return cached;\n    }\n    \n    const value = await factory();\n    await this.set(key, value, options);\n    return value;\n  }\n\n  /**\n   * Delete specific key\n   */\n  async delete(key: string, namespace?: string): Promise<boolean> {\n    const fullKey = this.buildKey(key, namespace);\n    \n    try {\n      // Remove from memory cache\n      this.memoryCache.delete(fullKey);\n      \n      // Remove from Redis\n      \1 {\n  \2{\n        await this.redis.del(fullKey);\n        await this.removeTagMappings(fullKey);\n      }\n      \n      this.operationCounter++;\n      this.emit('cache_delete', { key: fullKey });\n      \n      return true;\n    } catch (error) {\n      // Debug logging removed\n      this.emit('cache_error', { operation: 'delete', key: fullKey, error });\n      return false;\n    }\n  }\n\n  /**\n   * Clear cache by pattern\n   */\n  async deletePattern(pattern: string, namespace?: string): Promise<number> {\n    const fullPattern = this.buildKey(pattern, namespace);\n    let deletedCount = 0;\n    \n    try {\n      // Clear from memory cache\n      const memoryKeys = Array.from(this.memoryCache.keys());\n      for (const key of memoryKeys) {\n        \1 {\n  \2 {\n          this.memoryCache.delete(key);\n          deletedCount++;\n        }\n      }\n      \n      // Clear from Redis\n      \1 {\n  \2{\n        const redisKeys = await this.redis.keys(fullPattern);\n        \1 {\n  \2{\n          await this.redis.del(...redisKeys);\n          deletedCount += redisKeys.length;\n          \n          // Remove tag mappings\n          for (const key of redisKeys) {\n            await this.removeTagMappings(key);\n          }\n        }\n      }\n      \n      this.operationCounter++;\n      this.emit('cache_delete_pattern', { pattern: fullPattern, deletedCount });\n      \n      return deletedCount;\n    } catch (error) {\n      // Debug logging removed\n      this.emit('cache_error', { operation: 'deletePattern', pattern: fullPattern, error });\n      return 0;\n    }\n  }\n\n  /**\n   * Clear cache by tags\n   */\n  async deleteByTags(tags: string[]): Promise<number> {\n    \1 {\n  \2eturn 0;\n    \n    let deletedCount = 0;\n    \n    try {\n      const keysToDelete = new Set<string>();\n      \n      // Find all keys with these tags\n      for (const tag of tags) {\n        const tagKey = `${this.config.keyPrefix}tags:${tag}`;\n        const keys = await this.redis.smembers(tagKey);\n        keys.forEach(key => keysToDelete.add(key));\n      }\n      \n      // Delete the keys\n      for (const key of keysToDelete) {\n        await this.delete(key.replace(this.config.keyPrefix, ''));\n        deletedCount++;\n      }\n      \n      this.emit('cache_delete_tags', { tags, deletedCount });\n      \n      return deletedCount;\n    } catch (error) {\n      // Debug logging removed\n      this.emit('cache_error', { operation: 'deleteByTags', tags, error });\n      return 0;\n    }\n  }\n\n  /**\n   * Clear all cache\n   */\n  async clear(): Promise<void> {\n    try {\n      // Clear memory cache\n      this.memoryCache.clear();\n      \n      // Clear Redis cache\n      \1 {\n  \2{\n        const keys = await this.redis.keys(`${this.config.keyPrefix}*`);\n        \1 {\n  \2{\n          await this.redis.del(...keys);\n        }\n      }\n      \n      this.emit('cache_clear');\n    } catch (error) {\n      // Debug logging removed\n      this.emit('cache_error', { operation: 'clear', error });\n    }\n  }\n\n  /**\n   * Check if key exists\n   */\n  async exists(key: string, namespace?: string): Promise<boolean> {\n    const fullKey = this.buildKey(key, namespace);\n    \n    // Check memory cache\n    \1 {\n  \2 {\n      const entry = this.memoryCache.get(fullKey)!;\n      \1 {\n  \2 {\n        return true;\n      }\n    }\n    \n    // Check Redis cache\n    \1 {\n  \2{\n      const exists = await this.redis.exists(fullKey);\n      return exists === 1;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): CacheStats {\n    this.updateStats();\n    return { ...this.stats };\n  }\n\n  /**\n   * Register cache key pattern\n   */\n  registerPattern(name: string, pattern: CacheKeyPattern): void {\n    this.keyPatterns.set(name, pattern);\n    this.emit('pattern_registered', { name, pattern });\n  }\n\n  /**\n   * Create cache invalidation rule\n   */\n  createInvalidationRule(\n    name: string,\n    triggers: CacheInvalidationTrigger[],\n    targets: CacheInvalidationTarget[]\n  ): string {\n    const ruleId = uuidv4();\n    \n    const rule: CacheInvalidationRule = {\n      id: ruleId,\n      name,\n      triggers,\n      targets,\n      isActive: true,\n      createdAt: new Date(),\n      triggerCount: 0\n    };\n    \n    this.invalidationRules.set(ruleId, rule);\n    this.emit('invalidation_rule_created', rule);\n    \n    return ruleId;\n  }\n\n  /**\n   * Trigger cache invalidation\n   */\n  async invalidate(eventType: string, eventData?: unknown): Promise<void> {\n    const triggeredRules: CacheInvalidationRule[] = [];\n    \n    for (const rule of this.invalidationRules.values()) {\n      \1 {\n  \2ontinue;\n      \n      const shouldTrigger = rule.triggers.some(trigger => {\n        \1 {\n  \2n          return true;\n        \n        \1 {\n  \2{\n          return true;\n        }\n        return false;\n      });\n      \n      \1 {\n  \2{\n        triggeredRules.push(rule);\n        rule.lastTriggered = new Date();\n        rule.triggerCount++;\n      }\n    }\n    \n    // Execute invalidation targets\n    for (const rule of triggeredRules) {\n      for (const target of rule.targets) {\n        await this.executeInvalidationTarget(target);\n      }\n    }\n    \n    \1 {\n  \2{\n      this.emit('cache_invalidation', { \n        eventType, \n        eventData, \n        triggeredRules: triggeredRules.map(r => r.name) \n      });\n    }\n  }\n\n  /**\n   * Warm up cache with commonly accessed data\n   */\n  async warmup(entries: Array<{ key: string, factory: () => Promise<unknown>; options?: CacheOptions }>): Promise<void> {\n    const warmupPromises = entries.map(async ({ key, factory, options }) => {\n      try {\n        const exists = await this.exists(key, options?.namespace);\n        \1 {\n  \2{\n          const value = await factory();\n          await this.set(key, value, options);\n        }\n      } catch (error) {\n        // Debug logging removed\n      }\n    });\n    \n    await Promise.allSettled(warmupPromises);\n    this.emit('cache_warmup_complete', { entriesCount: entries.length });\n  }\n\n  /**\n   * Export cache data for backup\n   */\n  async exportData(): Promise<{ entries: CacheEntry[], metadata: unknown }> {\n    const entries: CacheEntry[] = [];\n    \n    // Export from memory cache\n    for (const [key, entry] of this.memoryCache.entries()) {\n      \1 {\n  \2 {\n        entries.push({ ...entry });\n      }\n    }\n    \n    // Export from Redis would require scanning all keys\n    // This is typically done as a background job\n    \n    return {\n      entries,\n      metadata: {\n        exportedAt: new Date(),\n        nodeId: this.nodeId,\n        totalEntries: entries.length,\n        config: this.config\n      }\n    };\n  }\n\n  /**\n   * Import cache data from backup\n   */\n  async importData(data: { entries: CacheEntry[], metadata: unknown }): Promise<void> {\n    let importedCount = 0;\n    \n    for (const entry of data.entries) {\n      \1 {\n  \2 {\n        // Calculate remaining TTL\n        const remainingTTL = Math.max(0, Math.floor((entry.expiresAt.getTime() - crypto.getRandomValues(new Uint32Array(1))[0]) / 1000));\n        \n        \1 {\n  \2{\n          await this.set(entry.key.replace(this.config.keyPrefix, ''), entry.value, {\n            ttl: remainingTTL,\n            tags: entry.tags,\n            version: entry.version,\n            namespace: entry.namespace,\n            priority: entry.priority\n          });\n          importedCount++;\n        }\n      }\n    }\n    \n    this.emit('cache_import_complete', { \n      totalEntries: data.entries.length, \n      importedCount \n    });\n  }\n\n  // Private methods\n\n  private async initializeRedis(): Promise<void> {\n    try {\n      this.redis = new Redis(this.config.redisUrl);\n      \n      this.redis.on('connect', () => {\n        // RESOLVED: (Priority: Medium, Target: Next Sprint): \1 - Automated quality improvement
