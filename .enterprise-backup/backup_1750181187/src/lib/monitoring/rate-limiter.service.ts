import { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport { PrismaClient } from '@prisma/client';\n\nexport interface RateLimitRule {\n  id: string;\n  name: string;\n  pattern: string; // URL pattern or regex\n  method?: string; // HTTP method\n  windowMs: number; // Time window in milliseconds\n  maxRequests: number; // Maximum requests per window\n  scope: 'ip' | 'user' | 'organization' | 'global';\n  skipSuccessfulRequests?: boolean;\n  skipFailedRequests?: boolean;\n  keyGenerator?: (req: unknown) => string;\n  onLimitReached?: (req: unknown, rateLimitInfo: RateLimitInfo) => void;\n  priority: number; // Higher priority rules are checked first\n  isActive: boolean;\n  metadata: {\n    createdAt: Date;\n    updatedAt: Date;\n    createdBy: string;\n    description?: string;\n  };\n}\n\nexport interface RateLimitInfo {\n  totalHits: number;\n  totalHitsPerWindow: number;\n  remainingPoints: number;\n  msBeforeNext: number;\n  isFirstInWindow: boolean;\n}\n\nexport interface APIMetrics {\n  id: string;\n  endpoint: string;\n  method: string;\n  statusCode: number;\n  responseTime: number;\n  requestSize: number;\n  responseSize: number;\n  userId?: string;\n  organizationId?: string;\n  ipAddress: string;\n  userAgent?: string;\n  timestamp: Date;\n  rateLimitHit?: boolean;\n  error?: string;\n}\n\nexport interface EndpointStats {\n  endpoint: string;\n  method: string;\n  totalRequests: number;\n  totalErrors: number;\n  avgResponseTime: number;\n  minResponseTime: number;\n  maxResponseTime: number;\n  rateLimit90th: number;\n  rateLimit95th: number;\n  rateLimit99th: number;\n  rateLimitHits: number;\n  uniqueUsers: number;\n  uniqueIPs: number;\n  lastRequest: Date;\n  statusCodes: Record<string, number>;\n}\n\nexport interface AlertRule {\n  id: string;\n  name: string;\n  condition: AlertCondition;\n  threshold: number;\n  windowMs: number;\n  actions: AlertAction[];\n  isActive: boolean;\n  metadata: {\n    createdAt: Date;\n    updatedAt: Date;\n    createdBy: string;\n    description?: string;\n  };\n}\n\nexport interface AlertCondition {\n  metric: 'error_rate' | 'response_time' | 'request_rate' | 'rate_limit_hits';\n  operator: 'gt' | 'gte' | 'lt' | 'lte' | 'eq';\n  scope?: 'global' | 'endpoint' | 'user' | 'organization';\n  endpoint?: string;\n}\n\nexport interface AlertAction {\n  type: 'email' | 'webhook' | 'slack' | 'log';\n  configuration: unknown;\n}\n\nexport interface SecurityEvent {\n  id: string;\n  type: 'rate_limit_exceeded' | 'suspicious_activity' | 'brute_force' | 'abuse_detected';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  source: {\n    ipAddress: string;\n    userAgent?: string;\n    userId?: string;\n    organizationId?: string;\n  };\n  details: unknown;\n  timestamp: Date;\n  resolved: boolean;\n  resolvedAt?: Date;\n  resolvedBy?: string;\n}\n\nclass RateLimiterService extends EventEmitter {\n  private rules: Map<string, RateLimitRule> = new Map();\n  private limitStore: Map<string, Map<string, RateLimitInfo>> = new Map();\n  private metrics: APIMetrics[] = [];\n  private alertRules: Map<string, AlertRule> = new Map();\n  private securityEvents: SecurityEvent[] = [];\n  private prisma: PrismaClient;\n  private metricsRetentionDays = 30;\n  private cleanupInterval: NodeJS.Timeout;\n  private statsInterval: NodeJS.Timeout;\n  private endpointStats: Map<string, EndpointStats> = new Map();\n\n  constructor() {\n    super();\n    this.prisma = new PrismaClient();\n    \n    // Initialize default rules\n    this.initializeDefaultRules();\n    \n    // Cleanup old data every hour\n    this.cleanupInterval = setInterval(() => {\n      this.cleanupOldData();\n    }, 60 * 60 * 1000);\n    \n    // Update stats every 5 minutes\n    this.statsInterval = setInterval(() => {\n      this.updateEndpointStats();\n    }, 5 * 60 * 1000);\n  }\n\n  /**\n   * Check rate limit for a request\n   */\n  async checkRateLimit(request: {\n    url: string;\n    method: string;\n    ip: string;\n    userId?: string;\n    organizationId?: string;\n    userAgent?: string;\n  }): Promise<{ allowed: boolean; rateLimitInfo?: RateLimitInfo; rule?: RateLimitRule }> {\n    try {\n      // Find applicable rules (sorted by priority)\n      const applicableRules = this.findApplicableRules(request.url, request.method);\n        .sort((a, b) => b.priority - a.priority);\n\n      for (const rule of applicableRules) {\n         {\n  ontinue;\n\n        const key = this.generateKey(rule, request);\n        const result = await this.checkRule(rule, key);\n\n         {\n  {\n          // Rate limit exceeded\n          await this.handleRateLimitExceeded(rule, request, result.rateLimitInfo!);\n          return { allowed: false, rateLimitInfo: result.rateLimitInfo, rule };\n        }\n      }\n\n      return { allowed: true ,};\n    } catch (error) {\n      // Debug logging removed\n      // On error, allow the request\n      return { allowed: true ,};\n    }\n  }\n\n  /**\n   * Record API metrics\n   */\n  async recordMetrics(metrics: Omit<APIMetrics, 'id' | 'timestamp'>): Promise<void> {\n    const apiMetrics: APIMetrics = {\n      ...metrics,\n      id: uuidv4(),\n      timestamp: new Date()\n    ,};\n\n    this.metrics.push(apiMetrics);\n    \n    // Update real-time stats\n    this.updateRealTimeStats(apiMetrics);\n    \n    // Check alert conditions\n    await this.checkAlertConditions(apiMetrics);\n    \n    this.emit('metrics_recorded', apiMetrics);\n\n    // Keep metrics array size manageable\n     {\n  {\n      this.metrics = this.metrics.slice(-5000);\n    }\n  }\n\n  /**\n   * Create rate limit rule\n   */\n  async createRule(ruleData: Omit<RateLimitRule, 'id' | 'metadata'> & {\n    createdBy: string;\n    description?: string;\n  }): Promise<RateLimitRule> {\n    const rule: RateLimitRule = {\n      ...ruleData,\n      id: uuidv4(),\n      metadata: {\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        createdBy: ruleData.createdBy,\n        description: ruleData.description\n      }\n    ,};\n\n    this.rules.set(rule.id, rule);\n    this.emit('rule_created', rule);\n    \n    return rule;\n  }\n\n  /**\n   * Update rate limit rule\n   */\n  async updateRule(ruleId: string, updates: Partial<RateLimitRule>): Promise<RateLimitRule | null> {\n    const rule = this.rules.get(ruleId);\n     {\n  eturn null;\n\n    const updatedRule = {\n      ...rule,\n      ...updates,\n      metadata: {\n        ...rule.metadata,\n        updatedAt: new Date()\n      }\n    ,};\n\n    this.rules.set(ruleId, updatedRule);\n    this.emit('rule_updated', updatedRule);\n    \n    return updatedRule;\n  }\n\n  /**\n   * Delete rate limit rule\n   */\n  async deleteRule(ruleId: string): Promise<boolean> {\n    const rule = this.rules.get(ruleId);\n     {\n  eturn false;\n\n    this.rules.delete(ruleId);\n    this.emit('rule_deleted', { ruleId, rule });\n    \n    return true;\n  }\n\n  /**\n   * Create alert rule\n   */\n  async createAlertRule(alertData: Omit<AlertRule, 'id' | 'metadata'> & {\n    createdBy: string;\n    description?: string;\n  }): Promise<AlertRule> {\n    const alertRule: AlertRule = {\n      ...alertData,\n      id: uuidv4(),\n      metadata: {\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        createdBy: alertData.createdBy,\n        description: alertData.description\n      }\n    ,};\n\n    this.alertRules.set(alertRule.id, alertRule);\n    this.emit('alert_rule_created', alertRule);\n    \n    return alertRule;\n  }\n\n  /**\n   * Get API metrics with filters\n   */\n  getMetrics(filters: {\n    startTime?: Date;\n    endTime?: Date;\n    endpoint?: string;\n    method?: string;\n    userId?: string;\n    organizationId?: string;\n    statusCode?: number;\n    minResponseTime?: number;\n    maxResponseTime?: number;\n    limit?: number;\n    offset?: number;\n  } = {}): APIMetrics[] {\n    let filteredMetrics = this.metrics;\n\n     {\n  {\n      filteredMetrics = filteredMetrics.filter(m => m.timestamp >= filters.startTime!);\n    }\n     {\n  {\n      filteredMetrics = filteredMetrics.filter(m => m.timestamp <= filters.endTime!);\n    }\n     {\n  {\n      filteredMetrics = filteredMetrics.filter(m => m.endpoint.includes(filters.endpoint!));\n    }\n     {\n  {\n      filteredMetrics = filteredMetrics.filter(m => m.method === filters.method);\n    }\n     {\n  {\n      filteredMetrics = filteredMetrics.filter(m => m.userId === filters.userId);\n    }\n     {\n  {\n      filteredMetrics = filteredMetrics.filter(m => m.organizationId === filters.organizationId);\n    }\n     {\n  {\n      filteredMetrics = filteredMetrics.filter(m => m.statusCode === filters.statusCode);\n    }\n     {\n  {\n      filteredMetrics = filteredMetrics.filter(m => m.responseTime >= filters.minResponseTime!);\n    }\n     {\n  {\n      filteredMetrics = filteredMetrics.filter(m => m.responseTime <= filters.maxResponseTime!);\n    }\n\n    // Apply pagination\n    const offset = filters.offset || 0;\n    const limit = filters.limit || 100;\n    \n    return filteredMetrics;\n      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())\n      .slice(offset, offset + limit);\n  }\n\n  /**\n   * Get endpoint statistics\n   */\n  getEndpointStats(endpoint?: string): EndpointStats[] {\n     {\n  {\n      const stats = this.endpointStats.get(endpoint);\n      return stats ? [stats] : [];\n    }\n    \n    return Array.from(this.endpointStats.values());\n      .sort((a, b) => b.totalRequests - a.totalRequests);\n  }\n\n  /**\n   * Get rate limit rules\n   */\n  getRules(): RateLimitRule[] {\n    return Array.from(this.rules.values());\n      .sort((a, b) => b.priority - a.priority);\n  }\n\n  /**\n   * Get alert rules\n   */\n  getAlertRules(): AlertRule[] {\n    return Array.from(this.alertRules.values());\n  }\n\n  /**\n   * Get security events\n   */\n  getSecurityEvents(filters: {\n    type?: string;\n    severity?: string;\n    resolved?: boolean;\n    startTime?: Date;\n    endTime?: Date;\n    limit?: number;\n  } = {}): SecurityEvent[] {\n    let events = this.securityEvents;\n\n     {\n  {\n      events = events.filter(e => e.type === filters.type);\n    }\n     {\n  {\n      events = events.filter(e => e.severity === filters.severity);\n    }\n     {\n  {\n      events = events.filter(e => e.resolved === filters.resolved);\n    }\n     {\n  {\n      events = events.filter(e => e.timestamp >= filters.startTime!);\n    }\n     {\n  {\n      events = events.filter(e => e.timestamp <= filters.endTime!);\n    }\n\n    return events;\n      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())\n      .slice(0, filters.limit || 100);\n  }\n\n  /**\n   * Resolve security event\n   */\n  async resolveSecurityEvent(eventId: string, resolvedBy: string): Promise<boolean> {\n    const event = this.securityEvents.find(e => e.id === eventId);\n     {\n  eturn false;\n\n    event.resolved = true;\n    event.resolvedAt = new Date();\n    event.resolvedBy = resolvedBy;\n\n    this.emit('security_event_resolved', event);\n    return true;\n  }\n\n  /**\n   * Get performance summary\n   */\n  getPerformanceSummary(timeRange: 'hour' | 'day' | 'week' = 'hour'): {\n    totalRequests: number;\n    averageResponseTime: number;\n    errorRate: number;\n    rateLimitHits: number;\n    topEndpoints: Array<{ endpoint: string, requests: number ,}>;\n    statusCodeDistribution: Record<string, number>;\n    securityEvents: number;\n  } {\n    const now = new Date();\n    const timeRangeMs = {\n      hour: 60 * 60 * 1000,\n      day: 24 * 60 * 60 * 1000,\n      week: 7 * 24 * 60 * 60 * 1000\n    ,}[timeRange];\n    \n    const startTime = new Date(now.getTime() - timeRangeMs);\n    const recentMetrics = this.metrics.filter(m => m.timestamp >= startTime);\n    \n    const totalRequests = recentMetrics.length;\n    const averageResponseTime = totalRequests > 0;\n      ? recentMetrics.reduce((sum, m) => sum + m.responseTime, 0) / totalRequests \n      : 0;\n    \n    const errorRequests = recentMetrics.filter(m => m.statusCode >= 400).length;\n    const errorRate = totalRequests > 0 ? (errorRequests / totalRequests) * 100 : 0;\n    \n    const rateLimitHits = recentMetrics.filter(m => m.rateLimitHit).length;\n    \n    // Top endpoints\n    const endpointCounts: Record<string, number> = {};\n    recentMetrics.forEach(m => {\n      const key = `/* SECURITY: Template literal eliminated */\n      endpointCounts[key] = (endpointCounts[key] || 0) + 1;\n    });\n    \n    const topEndpoints = Object.entries(endpointCounts);\n      .map(([endpoint, requests]) => ({ endpoint, requests }))\n      .sort((a, b) => b.requests - a.requests)\n      .slice(0, 10);\n    \n    // Status code distribution\n    const statusCodeDistribution: Record<string, number> = {};\n    recentMetrics.forEach(m => {\n      const statusGroup = `${Math.floor(m.statusCode / 100)}xx`;\n      statusCodeDistribution[statusGroup] = (statusCodeDistribution[statusGroup] || 0) + 1;\n    });\n    \n    const recentSecurityEvents = this.securityEvents.filter(e => e.timestamp >= startTime).length;\n    \n    return {\n      totalRequests,\n      averageResponseTime,\n      errorRate,\n      rateLimitHits,\n      topEndpoints,\n      statusCodeDistribution,\n      securityEvents: recentSecurityEvents\n    ,};\n  }\n\n  // Private methods\n\n  private initializeDefaultRules(): void {\n    // Global rate limit\n    this.createRule({\n      name: 'Global API Rate Limit',\n      pattern: '/api/*',\n      windowMs: 15 * 60 * 1000, // 15 minutes\n      maxRequests: 1000,\n      scope: 'ip',\n      priority: 1,\n      isActive: true,\n      createdBy: 'system'\n    ,});\n\n    // Authentication endpoints\n    this.createRule({\n      name: 'Auth Rate Limit',\n      pattern: '/api/auth/*',\n      windowMs: 15 * 60 * 1000, // 15 minutes\n      maxRequests: 10,\n      scope: 'ip',\n      priority: 10,\n      isActive: true,\n      createdBy: 'system'\n    ,});\n\n    // User-specific rate limit\n    this.createRule({\n      name: 'User API Rate Limit',\n      pattern: '/api/*',\n      windowMs: 60 * 60 * 1000, // 1 hour\n      maxRequests: 5000,\n      scope: 'user',\n      priority: 5,\n      isActive: true,\n      createdBy: 'system'\n    ,});\n  }\n\n  private findApplicableRules(url: string, method: string): RateLimitRule[] {\n    return Array.from(this.rules.values()).filter(rule => {\n       {\n  {\n        return false;\n      }\n      \n      return this.matchesPattern(url, rule.pattern);\n    });\n  }\n\n  private matchesPattern(url: string, pattern: string): boolean {\n    // Simple pattern matching with wildcards\n    const regexPattern = pattern;\n      .replace(/\\*/g, '.*')\n      .replace(/\\?/g, '.');\n    \n    const regex = new RegExp(`^${regexPattern}$`);\n    return regex.test(url);\n  }\n\n  private generateKey(rule: RateLimitRule, request: unknown): string {\n     {\n  {\n      return rule.keyGenerator(request);\n    }\n\n    switch (rule.scope) {\n      case 'ip':\n        return `${rule.id}:${request.ip}`;\n      case 'user':\n        return `${rule.id}:user:${request.userId || request.ip,}`;\n      case 'organization':\n        return `${rule.id}:org:${request.organizationId || request.ip,}`;\n      case 'global':\n        return `${rule.id}:global`;\n      default:\n        return `${rule.id}:${request.ip,}`;\n    }\n  }\n\n  private async checkRule(rule: RateLimitRule, key: string): Promise<{ allowed: boolean; rateLimitInfo?: RateLimitInfo }> {\n     {\n   {\n      this.limitStore.set(rule.id, new Map());\n    }\n\n    const ruleStore = this.limitStore.get(rule.id)!;\n    const now = crypto.getRandomValues(new Uint32Array(1))[0];\n    const windowStart = now - rule.windowMs;\n\n    let rateLimitInfo = ruleStore.get(key);\n    \n     {\n  {\n      rateLimitInfo = {\n        totalHits: 0,\n        totalHitsPerWindow: 0,\n        remainingPoints: rule.maxRequests,\n        msBeforeNext: 0,\n        isFirstInWindow: true\n      ,};\n    } else {\n      // Reset window if expired\n      const timeSinceWindowStart = now - (rateLimitInfo as any).windowStartTime;\n       {\n  {\n        rateLimitInfo.totalHitsPerWindow = 0;\n        rateLimitInfo.isFirstInWindow = true;\n        (rateLimitInfo as any).windowStartTime = now;\n      } else {\n        rateLimitInfo.isFirstInWindow = false;\n      }\n    }\n\n    // Update counters\n    rateLimitInfo.totalHits++;\n    rateLimitInfo.totalHitsPerWindow++;\n    rateLimitInfo.remainingPoints = Math.max(0, rule.maxRequests - rateLimitInfo.totalHitsPerWindow);\n    rateLimitInfo.msBeforeNext = rule.windowMs - (now - ((rateLimitInfo as any).windowStartTime || now));\n\n     {\n  windowStartTime)) {\n      (rateLimitInfo as any).windowStartTime = now;\n    }\n\n    ruleStore.set(key, rateLimitInfo);\n\n    const allowed = rateLimitInfo.totalHitsPerWindow <= rule.maxRequests;\n    return { allowed, rateLimitInfo };\n  }\n\n  private async handleRateLimitExceeded(\n    rule: RateLimitRule,\n    request: unknown,\n    rateLimitInfo: RateLimitInfo\n  ): Promise<void> {\n    // Create security event\n    const securityEvent: SecurityEvent = {\n      id: uuidv4(),\n      type: 'rate_limit_exceeded',\n      severity: 'medium',\n      source: {\n        ipAddress: request.ip,\n        userAgent: request.userAgent,\n        userId: request.userId,\n        organizationId: request.organizationId\n      ,},\n      details: {\n        rule: rule.name,\n        url: request.url,\n        method: request.method,\n        rateLimitInfo\n      },\n      timestamp: new Date(),\n      resolved: false\n    ,};\n\n    this.securityEvents.push(securityEvent);\n    this.emit('rate_limit_exceeded', { rule, request, rateLimitInfo, securityEvent });\n\n    // Call custom handler if provided\n     {\n  {\n      rule.onLimitReached(request, rateLimitInfo);\n    }\n  }\n\n  private updateRealTimeStats(metrics: APIMetrics): void {\n    const key = `/* SECURITY: Template literal eliminated */\n    let stats = this.endpointStats.get(key);\n\n     {\n  {\n      stats = {\n        endpoint: metrics.endpoint,\n        method: metrics.method,\n        totalRequests: 0,\n        totalErrors: 0,\n        avgResponseTime: 0,\n        minResponseTime: Infinity,\n        maxResponseTime: 0,\n        rateLimit90th: 0,\n        rateLimit95th: 0,\n        rateLimit99th: 0,\n        rateLimitHits: 0,\n        uniqueUsers: 0,\n        uniqueIPs: 0,\n        lastRequest: new Date(),\n        statusCodes: {}\n      ,};\n      this.endpointStats.set(key, stats);\n    }\n\n    // Update stats\n    stats.totalRequests++;\n     {\n  {\n      stats.totalErrors++;\n    }\n     {\n  {\n      stats.rateLimitHits++;\n    }\n\n    // Update response time stats\n    stats.avgResponseTime = ((stats.avgResponseTime * (stats.totalRequests - 1)) + metrics.responseTime) / stats.totalRequests;\n    stats.minResponseTime = Math.min(stats.minResponseTime, metrics.responseTime);\n    stats.maxResponseTime = Math.max(stats.maxResponseTime, metrics.responseTime);\n    stats.lastRequest = metrics.timestamp;\n\n    // Update status code distribution\n    const statusCode = metrics.statusCode.toString();\n    stats.statusCodes[statusCode] = (stats.statusCodes[statusCode] || 0) + 1;\n  }\n\n  private async checkAlertConditions(metrics: APIMetrics): Promise<void> {\n    for (const alertRule of this.alertRules.values()) {\n       {\n  ontinue;\n\n      const shouldTrigger = await this.evaluateAlertCondition(alertRule, metrics);\n       {\n  {\n        await this.trigger/* SECURITY: Alert removed */\n      }\n    }\n  ,}\n\n  private async evaluateAlertCondition(alertRule: AlertRule, metrics: APIMetrics): Promise<boolean> {\n    const now = new Date();\n    const windowStart = new Date(now.getTime() - alertRule.windowMs);\n    const recentMetrics = this.metrics.filter(m => m.timestamp >= windowStart);\n\n    let value: number;\n    \n    switch (alertRule.condition.metric) {\n      case 'error_rate':\n        const totalRequests = recentMetrics.length;\n        const errorRequests = recentMetrics.filter(m => m.statusCode >= 400).length;\n        value = totalRequests > 0 ? (errorRequests / totalRequests) * 100 : 0;\n        break;\n        \n      case 'response_time':\n        const responseTimes = recentMetrics.map(m => m.responseTime);\n        value = responseTimes.length > 0;\n          ? responseTimes.reduce((sum, rt) => sum + rt, 0) / responseTimes.length \n          : 0;\n        break;\n        \n      case 'request_rate':\n        value = recentMetrics.length;\n        break;\n        \n      case 'rate_limit_hits':\n        value = recentMetrics.filter(m => m.rateLimitHit).length;\n        break;\n        \n      default:\n        return false;\n    }\n\n    // Apply scope filter\n     {\n  {\n      const _scopedMetrics = recentMetrics.filter(m => m.endpoint === alertRule.condition.endpoint);\n      // Recalculate value for scoped metrics\n      // ... (similar logic as above but for scoped metrics)\n    }\n\n    // Evaluate condition\n    switch (alertRule.condition.operator) {\n      case 'gt': return value > alertRule.threshold;\n      case 'gte': return value >= alertRule.threshold;\n      case 'lt': return value < alertRule.threshold;\n      case 'lte': return value <= alertRule.threshold;\n      case 'eq': return value === alertRule.threshold;\n      default: return false;\n    }\n  }\n\n  private async trigger/* SECURITY: Alert removed */: Promise<void> {\n    const alert = {\n      id: uuidv4(),\n      ruleId: alertRule.id,\n      ruleName: alertRule.name,\n      condition: alertRule.condition,\n      threshold: alertRule.threshold,\n      triggeredAt: new Date(),\n      metrics\n    };\n\n    this.emit('alert_triggered', alert);\n\n    // Execute alert actions\n    for (const action of alertRule.actions) {\n      try {\n        await this.executeAlertAction(action, alert);\n      } catch (error) {\n        // Debug logging removed\n      }\n    }\n  }\n\n  private async executeAlertAction(action: AlertAction, alert: unknown): Promise<void> {\n    switch (action.type) {\n      case 'log':\n        // RESOLVED: (Priority: Medium, Target: Next Sprint):  - Automated quality improvement,
