#!/usr/bin/env node\n\n/**\n * Comprehensive Health Check Monitor\n * Hospital Management System\n * \n * This script performs comprehensive health checks across all HMS components,\n * ensuring system reliability and early detection of issues.\n * \n * Features:\n * - Database connectivity and performance\n * - API endpoint availability and response times\n * - External service dependencies\n * - Healthcare-specific validations\n * - HIPAA compliance checks\n * - Security posture verification\n * - Performance metrics collection\n * \n * Usage:\n * node scripts/monitoring/health-check.js [--continuous] [--alert-webhook=URL]\n */\n\nconst http = require('http');\nconst https = require('https');\nconst { performance } = require('perf_hooks');\nconst os = require('os');\nconst fs = require('fs').promises;\nconst path = require('path');\nconst { spawn } = require('child_process');\nconst crypto = require('crypto');\n\n// Configuration\nconst CONFIG = {\n  baseUrl: process.env.HMS_BASE_URL || 'http://localhost:3000',\n  databaseUrl: process.env.DATABASE_URL || '',\n  redisUrl: process.env.REDIS_URL || '',\n  alertWebhook: process.env.ALERT_WEBHOOK_URL || '',\n  checkInterval: parseInt(process.env.HEALTH_CHECK_INTERVAL) || 60000, // 1 minute\n  timeoutMs: parseInt(process.env.HEALTH_CHECK_TIMEOUT) || 10000, // 10 seconds\n  retryCount: parseInt(process.env.HEALTH_CHECK_RETRIES) || 3,\n  continuous: process.argv.includes('--continuous'),\n  verbose: process.argv.includes('--verbose') || process.env.NODE_ENV === 'development',\n  environment: process.env.NODE_ENV || 'development'\n};\n\n// Health check results\nclass HealthCheckResult {\n  constructor(component, status, duration, details = {}) {\n    this.component = component;\n    this.status = status; // 'healthy', 'degraded', 'unhealthy'\n    this.duration = duration;\n    this.details = details;\n    this.timestamp = new Date().toISOString();\n    this.checkId = crypto.randomUUID();\n  }\n}\n\n// Health check monitor\nclass HealthMonitor {\n  constructor() {\n    this.results = [];\n    this.alertsSent = new Set();\n    this.lastHealthyTimestamp = new Date();\n    this.consecutiveFailures = 0;\n    \n    // Healthcare-specific thresholds\n    this.thresholds = {\n      apiResponseTime: 2000, // 2 seconds\n      databaseResponseTime: 1000, // 1 second\n      cpuUsage: 80, // 80%\n      memoryUsage: 85, // 85%\n      diskUsage: 90, // 90%\n      errorRate: 0.01, // 1%\n      hipaaComplianceScore: 90 // 90%\n    };\n    \n    // Critical endpoints for healthcare operations\n    this.criticalEndpoints = [\n      '/api/health',\n      '/api/patients/search',\n      '/api/appointments/today',\n      '/api/emergency/alerts',\n      '/api/auth/verify',\n      '/api/audit/recent',\n      '/api/fhir/patient',\n      '/api/billing/status',\n      '/api/pharmacy/availability',\n      '/api/laboratory/urgent'\n    ];\n  }\n  \n  async performHealthCheck() {\n    console.log(`üè• Starting comprehensive health check at ${new Date().toISOString()}`);\n    \n    const startTime = performance.now();\n    const results = [];\n    \n    try {\n      // 1. System Resource Checks\n      console.log('üìä Checking system resources...');\n      results.push(await this.checkSystemResources());\n      \n      // 2. Database Health\n      console.log('üóÑÔ∏è Checking database connectivity...');\n      results.push(await this.checkDatabase());\n      \n      // 3. Redis Cache Health\n      console.log('‚ö° Checking Redis cache...');\n      results.push(await this.checkRedis());\n      \n      // 4. API Endpoints Health\n      console.log('üåê Checking API endpoints...');\n      const apiResults = await this.checkApiEndpoints();\n      results.push(...apiResults);\n      \n      // 5. External Dependencies\n      console.log('üîó Checking external dependencies...');\n      results.push(await this.checkExternalDependencies());\n      \n      // 6. Healthcare-Specific Checks\n      console.log('üè• Performing healthcare-specific validations...');\n      results.push(await this.checkHealthcareCompliance());\n      \n      // 7. Security Posture\n      console.log('üîí Checking security posture...');\n      results.push(await this.checkSecurityPosture());\n      \n      // 8. Performance Metrics\n      console.log('‚ö° Collecting performance metrics...');\n      results.push(await this.checkPerformanceMetrics());\n      \n      // 9. Audit Trail Verification\n      console.log('üìã Verifying audit trails...');\n      results.push(await this.checkAuditTrails());\n      \n      // 10. FHIR Compliance\n      console.log('üî¨ Checking FHIR compliance...');\n      results.push(await this.checkFHIRCompliance());\n      \n    } catch (error) {\n      console.error('‚ùå Health check failed:', error.message);\n      results.push(new HealthCheckResult(\n        'health_monitor',\n        'unhealthy',\n        performance.now() - startTime,\n        { error: error.message }\n      ));\n    }\n    \n    const totalDuration = performance.now() - startTime;\n    \n    // Analyze results and determine overall health\n    const healthSummary = this.analyzeResults(results, totalDuration);\n    \n    // Store results\n    this.results = results;\n    \n    // Send alerts if necessary\n    await this.handleAlerts(healthSummary);\n    \n    // Log summary\n    this.logHealthSummary(healthSummary);\n    \n    return healthSummary;\n  }\n  \n  async checkSystemResources() {\n    const startTime = performance.now();\n    \n    try {\n      const cpuUsage = await this.getCPUUsage();\n      const memoryUsage = this.getMemoryUsage();\n      const diskUsage = await this.getDiskUsage();\n      const loadAverage = os.loadavg();\n      \n      const details = {\n        cpu: {\n          usage: cpuUsage,\n          loadAverage: loadAverage,\n          cores: os.cpus().length\n        },\n        memory: {\n          usage: memoryUsage,\n          total: os.totalmem(),\n          free: os.freemem(),\n          used: os.totalmem() - os.freemem()\n        },\n        disk: {\n          usage: diskUsage\n        },\n        uptime: os.uptime(),\n        platform: os.platform(),\n        nodeVersion: process.version\n      };\n      \n      // Determine status based on thresholds\n      let status = 'healthy';\n      if (cpuUsage > this.thresholds.cpuUsage || \n          memoryUsage > this.thresholds.memoryUsage || \n          diskUsage > this.thresholds.diskUsage) {\n        status = cpuUsage > 95 || memoryUsage > 95 || diskUsage > 95 ? 'unhealthy' : 'degraded';\n      }\n      \n      return new HealthCheckResult(\n        'system_resources',\n        status,\n        performance.now() - startTime,\n        details\n      );\n    } catch (error) {\n      return new HealthCheckResult(\n        'system_resources',\n        'unhealthy',\n        performance.now() - startTime,\n        { error: error.message }\n      );\n    }\n  }\n  \n  async checkDatabase() {\n    const startTime = performance.now();\n    \n    try {\n      // Test database connectivity and performance\n      const dbResult = await this.makeHttpRequest('GET', `${CONFIG.baseUrl}/api/health/database`);\n      \n      if (dbResult.statusCode === 200) {\n        const responseData = JSON.parse(dbResult.data);\n        const details = {\n          connectionPool: responseData.connectionPool || {},\n          queryPerformance: responseData.queryPerformance || {},\n          replicationStatus: responseData.replicationStatus || {},\n          backupStatus: responseData.lastBackup || null\n        };\n        \n        const responseTime = performance.now() - startTime;\n        const status = responseTime > this.thresholds.databaseResponseTime ? 'degraded' : 'healthy';\n        \n        return new HealthCheckResult(\n          'database',\n          status,\n          responseTime,\n          details\n        );\n      } else {\n        throw new Error(`Database health check failed: ${dbResult.statusCode}`);\n      }\n    } catch (error) {\n      return new HealthCheckResult(\n        'database',\n        'unhealthy',\n        performance.now() - startTime,\n        { error: error.message }\n      );\n    }\n  }\n  \n  async checkRedis() {\n    const startTime = performance.now();\n    \n    try {\n      const redisResult = await this.makeHttpRequest('GET', `${CONFIG.baseUrl}/api/health/redis`);\n      \n      if (redisResult.statusCode === 200) {\n        const responseData = JSON.parse(redisResult.data);\n        const details = {\n          memory: responseData.memory || {},\n          stats: responseData.stats || {},\n          keyspace: responseData.keyspace || {}\n        };\n        \n        return new HealthCheckResult(\n          'redis',\n          'healthy',\n          performance.now() - startTime,\n          details\n        );\n      } else {\n        throw new Error(`Redis health check failed: ${redisResult.statusCode}`);\n      }\n    } catch (error) {\n      return new HealthCheckResult(\n        'redis',\n        'unhealthy',\n        performance.now() - startTime,\n        { error: error.message }\n      );\n    }\n  }\n  \n  async checkApiEndpoints() {\n    const results = [];\n    \n    for (const endpoint of this.criticalEndpoints) {\n      const startTime = performance.now();\n      \n      try {\n        const result = await this.makeHttpRequest('GET', `${CONFIG.baseUrl}${endpoint}`);\n        const responseTime = performance.now() - startTime;\n        \n        let status = 'healthy';\n        if (result.statusCode !== 200) {\n          status = 'unhealthy';\n        } else if (responseTime > this.thresholds.apiResponseTime) {\n          status = 'degraded';\n        }\n        \n        results.push(new HealthCheckResult(\n          `api_endpoint_${endpoint.replace(/[^a-zA-Z0-9]/g, '_')}`,\n          status,\n          responseTime,\n          {\n            endpoint,\n            statusCode: result.statusCode,\n            responseSize: result.data ? result.data.length : 0\n          }\n        ));\n      } catch (error) {\n        results.push(new HealthCheckResult(\n          `api_endpoint_${endpoint.replace(/[^a-zA-Z0-9]/g, '_')}`,\n          'unhealthy',\n          performance.now() - startTime,\n          {\n            endpoint,\n            error: error.message\n          }\n        ));\n      }\n    }\n    \n    return results;\n  }\n  \n  async checkExternalDependencies() {\n    const startTime = performance.now();\n    \n    try {\n      // Check external healthcare services\n      const dependencies = [\n        { name: 'FHIR_Server', url: process.env.FHIR_SERVER_URL },\n        { name: 'Insurance_Verification', url: process.env.INSURANCE_API_URL },\n        { name: 'Lab_Integration', url: process.env.LAB_API_URL },\n        { name: 'Pharmacy_Network', url: process.env.PHARMACY_API_URL }\n      ];\n      \n      const dependencyResults = [];\n      \n      for (const dep of dependencies) {\n        if (dep.url) {\n          try {\n            const depStartTime = performance.now();\n            const result = await this.makeHttpRequest('GET', `${dep.url}/health`);\n            const depResponseTime = performance.now() - depStartTime;\n            \n            dependencyResults.push({\n              name: dep.name,\n              status: result.statusCode === 200 ? 'healthy' : 'unhealthy',\n              responseTime: depResponseTime\n            });\n          } catch (error) {\n            dependencyResults.push({\n              name: dep.name,\n              status: 'unhealthy',\n              error: error.message\n            });\n          }\n        }\n      }\n      \n      const unhealthyDeps = dependencyResults.filter(d => d.status === 'unhealthy');\n      const status = unhealthyDeps.length === 0 ? 'healthy' : \n                    unhealthyDeps.length < dependencyResults.length ? 'degraded' : 'unhealthy';\n      \n      return new HealthCheckResult(\n        'external_dependencies',\n        status,\n        performance.now() - startTime,\n        { dependencies: dependencyResults }\n      );\n    } catch (error) {\n      return new HealthCheckResult(\n        'external_dependencies',\n        'unhealthy',\n        performance.now() - startTime,\n        { error: error.message }\n      );\n    }\n  }\n  \n  async checkHealthcareCompliance() {\n    const startTime = performance.now();\n    \n    try {\n      // Check HIPAA compliance status\n      const complianceResult = await this.makeHttpRequest('GET', `${CONFIG.baseUrl}/api/compliance/hipaa/status`);\n      \n      if (complianceResult.statusCode === 200) {\n        const complianceData = JSON.parse(complianceResult.data);\n        const details = {\n          hipaaCompliance: complianceData.hipaaCompliance || {},\n          auditTrails: complianceData.auditTrails || {},\n          encryptionStatus: complianceData.encryptionStatus || {},\n          accessControls: complianceData.accessControls || {},\n          lastAssessment: complianceData.lastAssessment\n        };\n        \n        const complianceScore = complianceData.overallScore || 0;\n        const status = complianceScore >= this.thresholds.hipaaComplianceScore ? 'healthy' : \n                      complianceScore >= 75 ? 'degraded' : 'unhealthy';\n        \n        return new HealthCheckResult(\n          'healthcare_compliance',\n          status,\n          performance.now() - startTime,\n          details\n        );\n      } else {\n        throw new Error(`Compliance check failed: ${complianceResult.statusCode}`);\n      }\n    } catch (error) {\n      return new HealthCheckResult(\n        'healthcare_compliance',\n        'unhealthy',\n        performance.now() - startTime,\n        { error: error.message }\n      );\n    }\n  }\n  \n  async checkSecurityPosture() {\n    const startTime = performance.now();\n    \n    try {\n      const securityResult = await this.makeHttpRequest('GET', `${CONFIG.baseUrl}/api/security/posture`);\n      \n      if (securityResult.statusCode === 200) {\n        const securityData = JSON.parse(securityResult.data);\n        const details = {\n          tlsConfiguration: securityData.tlsConfiguration || {},\n          authenticationStatus: securityData.authenticationStatus || {},\n          firewallRules: securityData.firewallRules || {},\n          vulnerabilityCount: securityData.vulnerabilityCount || 0,\n          lastSecurityScan: securityData.lastSecurityScan\n        };\n        \n        const criticalVulns = securityData.criticalVulnerabilities || 0;\n        const status = criticalVulns === 0 ? 'healthy' : \n                      criticalVulns < 5 ? 'degraded' : 'unhealthy';\n        \n        return new HealthCheckResult(\n          'security_posture',\n          status,\n          performance.now() - startTime,\n          details\n        );\n      } else {\n        throw new Error(`Security posture check failed: ${securityResult.statusCode}`);\n      }\n    } catch (error) {\n      return new HealthCheckResult(\n        'security_posture',\n        'degraded', // Default to degraded rather than unhealthy for security checks\n        performance.now() - startTime,\n        { error: error.message }\n      );\n    }\n  }\n  \n  async checkPerformanceMetrics() {\n    const startTime = performance.now();\n    \n    try {\n      const metricsResult = await this.makeHttpRequest('GET', `${CONFIG.baseUrl}/api/metrics/performance`);\n      \n      if (metricsResult.statusCode === 200) {\n        const metricsData = JSON.parse(metricsResult.data);\n        const details = {\n          averageResponseTime: metricsData.averageResponseTime || 0,\n          requestsPerSecond: metricsData.requestsPerSecond || 0,\n          errorRate: metricsData.errorRate || 0,\n          activeConnections: metricsData.activeConnections || 0,\n          queueDepth: metricsData.queueDepth || 0\n        };\n        \n        const errorRate = metricsData.errorRate || 0;\n        const avgResponseTime = metricsData.averageResponseTime || 0;\n        \n        let status = 'healthy';\n        if (errorRate > this.thresholds.errorRate || avgResponseTime > this.thresholds.apiResponseTime) {\n          status = errorRate > 0.05 || avgResponseTime > 5000 ? 'unhealthy' : 'degraded';\n        }\n        \n        return new HealthCheckResult(\n          'performance_metrics',\n          status,\n          performance.now() - startTime,\n          details\n        );\n      } else {\n        throw new Error(`Performance metrics check failed: ${metricsResult.statusCode}`);\n      }\n    } catch (error) {\n      return new HealthCheckResult(\n        'performance_metrics',\n        'degraded',\n        performance.now() - startTime,\n        { error: error.message }\n      );\n    }\n  }\n  \n  async checkAuditTrails() {\n    const startTime = performance.now();\n    \n    try {\n      const auditResult = await this.makeHttpRequest('GET', `${CONFIG.baseUrl}/api/audit/health`);\n      \n      if (auditResult.statusCode === 200) {\n        const auditData = JSON.parse(auditResult.data);\n        const details = {\n          recentEntries: auditData.recentEntries || 0,\n          integrityStatus: auditData.integrityStatus || 'unknown',\n          retentionCompliance: auditData.retentionCompliance || false,\n          lastBackup: auditData.lastBackup\n        };\n        \n        const status = auditData.integrityStatus === 'intact' && auditData.retentionCompliance ? \n                      'healthy' : 'degraded';\n        \n        return new HealthCheckResult(\n          'audit_trails',\n          status,\n          performance.now() - startTime,\n          details\n        );\n      } else {\n        throw new Error(`Audit trails check failed: ${auditResult.statusCode}`);\n      }\n    } catch (error) {\n      return new HealthCheckResult(\n        'audit_trails',\n        'unhealthy',\n        performance.now() - startTime,\n        { error: error.message }\n      );\n    }\n  }\n  \n  async checkFHIRCompliance() {\n    const startTime = performance.now();\n    \n    try {\n      const fhirResult = await this.makeHttpRequest('GET', `${CONFIG.baseUrl}/api/fhir/metadata`);\n      \n      if (fhirResult.statusCode === 200) {\n        const fhirData = JSON.parse(fhirResult.data);\n        const details = {\n          fhirVersion: fhirData.fhirVersion || 'unknown',\n          implementationGuides: fhirData.implementationGuides || [],\n          supportedResources: fhirData.supportedResources || [],\n          capabilityStatement: fhirData.capabilityStatement || {}\n        };\n        \n        const status = fhirData.fhirVersion && fhirData.fhirVersion.startsWith('4.') ? \n                      'healthy' : 'degraded';\n        \n        return new HealthCheckResult(\n          'fhir_compliance',\n          status,\n          performance.now() - startTime,\n          details\n        );\n      } else {\n        throw new Error(`FHIR compliance check failed: ${fhirResult.statusCode}`);\n      }\n    } catch (error) {\n      return new HealthCheckResult(\n        'fhir_compliance',\n        'degraded',\n        performance.now() - startTime,\n        { error: error.message }\n      );\n    }\n  }\n  \n  analyzeResults(results, totalDuration) {\n    const healthyCount = results.filter(r => r.status === 'healthy').length;\n    const degradedCount = results.filter(r => r.status === 'degraded').length;\n    const unhealthyCount = results.filter(r => r.status === 'unhealthy').length;\n    \n    // Determine overall health status\n    let overallStatus = 'healthy';\n    if (unhealthyCount > 0) {\n      overallStatus = unhealthyCount > results.length * 0.3 ? 'unhealthy' : 'degraded';\n    } else if (degradedCount > 0) {\n      overallStatus = 'degraded';\n    }\n    \n    // Calculate health score (0-100)\n    const healthScore = Math.round(\n      ((healthyCount * 100) + (degradedCount * 50) + (unhealthyCount * 0)) / results.length\n    );\n    \n    // Identify critical issues\n    const criticalIssues = results.filter(r => \n      r.status === 'unhealthy' && \n      ['database', 'security_posture', 'healthcare_compliance'].includes(r.component)\n    );\n    \n    return {\n      timestamp: new Date().toISOString(),\n      overallStatus,\n      healthScore,\n      totalDuration,\n      totalChecks: results.length,\n      healthyCount,\n      degradedCount,\n      unhealthyCount,\n      criticalIssues: criticalIssues.length,\n      results,\n      environment: CONFIG.environment,\n      version: process.env.APP_VERSION || 'unknown'\n    };\n  }\n  \n  async handleAlerts(healthSummary) {\n    const shouldAlert = (\n      healthSummary.overallStatus === 'unhealthy' ||\n      healthSummary.criticalIssues > 0 ||\n      healthSummary.healthScore < 70\n    );\n    \n    if (shouldAlert) {\n      this.consecutiveFailures++;\n      \n      // Send alert if this is the first failure or every 5th consecutive failure\n      if (this.consecutiveFailures === 1 || this.consecutiveFailures % 5 === 0) {\n        await this.sendAlert(healthSummary);\n      }\n    } else {\n      // Reset failure counter on successful check\n      if (this.consecutiveFailures > 0) {\n        await this.sendRecoveryAlert(healthSummary);\n        this.consecutiveFailures = 0;\n      }\n      this.lastHealthyTimestamp = new Date();\n    }\n  }\n  \n  async sendAlert(healthSummary) {\n    const alertData = {\n      timestamp: new Date().toISOString(),\n      severity: healthSummary.overallStatus === 'unhealthy' ? 'critical' : 'warning',\n      system: 'Hospital Management System',\n      environment: CONFIG.environment,\n      healthScore: healthSummary.healthScore,\n      overallStatus: healthSummary.overallStatus,\n      criticalIssues: healthSummary.criticalIssues,\n      consecutiveFailures: this.consecutiveFailures,\n      unhealthyComponents: healthSummary.results\n        .filter(r => r.status === 'unhealthy')\n        .map(r => r.component),\n      message: this.generateAlertMessage(healthSummary)\n    };\n    \n    try {\n      if (CONFIG.alertWebhook) {\n        await this.makeHttpRequest('POST', CONFIG.alertWebhook, JSON.stringify(alertData));\n        console.log('üö® Alert sent successfully');\n      } else {\n        console.log('‚ö†Ô∏è Alert would be sent:', alertData.message);\n      }\n    } catch (error) {\n      console.error('‚ùå Failed to send alert:', error.message);\n    }\n  }\n  \n  async sendRecoveryAlert(healthSummary) {\n    const recoveryData = {\n      timestamp: new Date().toISOString(),\n      severity: 'info',\n      system: 'Hospital Management System',\n      environment: CONFIG.environment,\n      healthScore: healthSummary.healthScore,\n      overallStatus: healthSummary.overallStatus,\n      downtimeDuration: Date.now() - this.lastHealthyTimestamp.getTime(),\n      message: '‚úÖ System health has been restored. All critical components are now operational.'\n    };\n    \n    try {\n      if (CONFIG.alertWebhook) {\n        await this.makeHttpRequest('POST', CONFIG.alertWebhook, JSON.stringify(recoveryData));\n        console.log('‚úÖ Recovery alert sent successfully');\n      }\n    } catch (error) {\n      console.error('‚ùå Failed to send recovery alert:', error.message);\n    }\n  }\n  \n  generateAlertMessage(healthSummary) {\n    const unhealthyComponents = healthSummary.results\n      .filter(r => r.status === 'unhealthy')\n      .map(r => r.component);\n    \n    let message = `üö® HMS Health Alert - ${healthSummary.overallStatus.toUpperCase()}\\n\\n`;\n    message += `Environment: ${CONFIG.environment}\\n`;\n    message += `Health Score: ${healthSummary.healthScore}/100\\n`;\n    message += `Critical Issues: ${healthSummary.criticalIssues}\\n`;\n    message += `Consecutive Failures: ${this.consecutiveFailures}\\n\\n`;\n    \n    if (unhealthyComponents.length > 0) {\n      message += `Unhealthy Components:\\n${unhealthyComponents.map(c => `‚Ä¢ ${c}`).join('\\n')}\\n\\n`;\n    }\n    \n    message += 'Immediate action required for healthcare system stability.';\n    \n    return message;\n  }\n  \n  logHealthSummary(healthSummary) {\n    const statusEmoji = {\n      healthy: '‚úÖ',\n      degraded: '‚ö†Ô∏è',\n      unhealthy: '‚ùå'\n    };\n    \n    console.log('\\n' + '='.repeat(80));\n    console.log('üè• HOSPITAL MANAGEMENT SYSTEM HEALTH SUMMARY');\n    console.log('='.repeat(80));\n    console.log(`${statusEmoji[healthSummary.overallStatus]} Overall Status: ${healthSummary.overallStatus.toUpperCase()}`);\n    console.log(`üìä Health Score: ${healthSummary.healthScore}/100`);\n    console.log(`‚è±Ô∏è Check Duration: ${healthSummary.totalDuration.toFixed(1)}ms`);\n    console.log(`üî¢ Total Checks: ${healthSummary.totalChecks}`);\n    console.log(`‚úÖ Healthy: ${healthSummary.healthyCount}`);\n    console.log(`‚ö†Ô∏è Degraded: ${healthSummary.degradedCount}`);\n    console.log(`‚ùå Unhealthy: ${healthSummary.unhealthyCount}`);\n    console.log(`üö® Critical Issues: ${healthSummary.criticalIssues}`);\n    \n    if (CONFIG.verbose) {\n      console.log('\\nüìã Component Details:');\n      healthSummary.results.forEach(result => {\n        const emoji = statusEmoji[result.status];\n        console.log(`${emoji} ${result.component}: ${result.status} (${result.duration.toFixed(1)}ms)`);\n        if (result.details.error) {\n          console.log(`   Error: ${result.details.error}`);\n        }\n      });\n    }\n    \n    console.log('='.repeat(80));\n  }\n  \n  // Utility methods\n  async getCPUUsage() {\n    return new Promise((resolve) => {\n      const startMeasure = this.cpuAverage();\n      setTimeout(() => {\n        const endMeasure = this.cpuAverage();\n        const idleDifference = endMeasure.idle - startMeasure.idle;\n        const totalDifference = endMeasure.total - startMeasure.total;\n        const cpuPercentage = 100 - ~~(100 * idleDifference / totalDifference);\n        resolve(cpuPercentage);\n      }, 1000);\n    });\n  }\n  \n  cpuAverage() {\n    const cpus = os.cpus();\n    let user = 0, nice = 0, sys = 0, idle = 0, irq = 0;\n    \n    for (const cpu of cpus) {\n      user += cpu.times.user;\n      nice += cpu.times.nice;\n      sys += cpu.times.sys;\n      idle += cpu.times.idle;\n      irq += cpu.times.irq;\n    }\n    \n    const total = user + nice + sys + idle + irq;\n    return { idle, total };\n  }\n  \n  getMemoryUsage() {\n    const totalMemory = os.totalmem();\n    const freeMemory = os.freemem();\n    const usedMemory = totalMemory - freeMemory;\n    return Math.round((usedMemory / totalMemory) * 100);\n  }\n  \n  async getDiskUsage() {\n    try {\n      const { stdout } = await this.execCommand('df -h /');\n      const lines = stdout.trim().split('\\n');\n      if (lines.length > 1) {\n        const columns = lines[1].split(/\\s+/);\n        const usagePercentage = columns[4];\n        return parseInt(usagePercentage.replace('%', ''));\n      }\n    } catch (error) {\n      console.warn('Could not get disk usage:', error.message);\n    }\n    return 0;\n  }\n  \n  async execCommand(command) {\n    return new Promise((resolve, reject) => {\n      const child = spawn('sh', ['-c', command]);\n      let stdout = '';\n      let stderr = '';\n      \n      child.stdout.on('data', (data) => {\n        stdout += data;\n      });\n      \n      child.stderr.on('data', (data) => {\n        stderr += data;\n      });\n      \n      child.on('close', (code) => {\n        if (code === 0) {\n          resolve({ stdout, stderr });\n        } else {\n          reject(new Error(`Command failed with code ${code}: ${stderr}`));\n        }\n      });\n    });\n  }\n  \n  async makeHttpRequest(method, url, data = null) {\n    return new Promise((resolve, reject) => {\n      const urlObj = new URL(url);\n      const options = {\n        hostname: urlObj.hostname,\n        port: urlObj.port,\n        path: urlObj.pathname + urlObj.search,\n        method: method,\n        headers: {\n          'User-Agent': 'HMS-Health-Monitor/1.0',\n          'Accept': 'application/json'\n        },\n        timeout: CONFIG.timeoutMs\n      };\n      \n      if (data) {\n        options.headers['Content-Type'] = 'application/json';\n        options.headers['Content-Length'] = Buffer.byteLength(data);\n      }\n      \n      const protocol = urlObj.protocol === 'https:' ? https : http;\n      \n      const req = protocol.request(options, (res) => {\n        let responseData = '';\n        \n        res.on('data', (chunk) => {\n          responseData += chunk;\n        });\n        \n        res.on('end', () => {\n          resolve({\n            statusCode: res.statusCode,\n            headers: res.headers,\n            data: responseData\n          });\n        });\n      });\n      \n      req.on('error', (error) => {\n        reject(error);\n      });\n      \n      req.on('timeout', () => {\n        req.destroy();\n        reject(new Error(`Request timeout after ${CONFIG.timeoutMs}ms`));\n      });\n      \n      if (data) {\n        req.write(data);\n      }\n      \n      req.end();\n    });\n  }\n  \n  async start() {\n    console.log('üè• Starting HMS Health Monitor...');\n    console.log(`Environment: ${CONFIG.environment}`);\n    console.log(`Base URL: ${CONFIG.baseUrl}`);\n    console.log(`Check Interval: ${CONFIG.checkInterval}ms`);\n    console.log(`Continuous Mode: ${CONFIG.continuous}`);\n    \n    // Perform initial health check\n    await this.performHealthCheck();\n    \n    if (CONFIG.continuous) {\n      console.log('\\nüîÑ Starting continuous health monitoring...');\n      setInterval(async () => {\n        try {\n          await this.performHealthCheck();\n        } catch (error) {\n          console.error('‚ùå Health check iteration failed:', error.message);\n        }\n      }, CONFIG.checkInterval);\n      \n      // Keep the process running\n      process.on('SIGINT', () => {\n        console.log('\\nüëã Shutting down health monitor...');\n        process.exit(0);\n      });\n    }\n  }\n}\n\n// Main execution\nif (require.main === module) {\n  const monitor = new HealthMonitor();\n  monitor.start().catch(error => {\n    console.error('‚ùå Health monitor failed to start:', error.message);\n    process.exit(1);\n  });\n}\n\nmodule.exports = HealthMonitor;\n"
      }
    }
  ]
}