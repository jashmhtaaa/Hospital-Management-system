"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._POST = void 0;
require("@/lib/database");
require("next/server");
require("zod");
const database_1 = require("@/lib/database");
from;
"@/lib/database";
const auth_1 = require("@/lib/auth"); // Assuming password hashing utility;
// Zod schema for patient registration;
const patientRegisterSchema = z.object({ mrn: z.string().optional(), // MRN might be generated by the system;
    first_name: z.string().min(1, "First name is required"),
    last_name: z.string().min(1, "Last name is required"),
    date_of_birth: z.string().refine((val) => !isNaN(Date.parse(val)), { message: "Invalid date of birth format"
    }),
    gender: z.enum(["Male", "Female", "Other", "Unknown"]), // Enforce specific values;
    contact_number: z.string().optional().nullable(),
    email: z.string().email("Invalid email address").optional().nullable(),
    address_line1: z.string().optional().nullable(),
    address_line2: z.string().optional().nullable(),
    city: z.string().optional().nullable(),
    state: z.string().optional().nullable(),
    postal_code: z.string().optional().nullable(),
    country: z.string().optional().nullable(),
    // Emergency contact details;
    emergency_contact_name: z.string().optional().nullable(),
    emergency_contact_relation: z.string().optional().nullable(),
    emergency_contact_number: z.string().optional().nullable(),
    // Basic medical info;
    blood_group: z.string().optional().nullable(),
    allergies: z.string().optional().nullable(),
    medical_history_summary: z.string().optional().nullable(),
    // Insurance details;
    insurance_provider: z.string().optional().nullable(),
    insurance_policy_number: z.string().optional().nullable(),
    // User account details (if creating a linked user account);
    create_user_account: z.boolean().optional().default(false),
    username: z.string().optional(), // Required if create_user_account is true;
    password: z.string().optional(), // Required if create_user_account is true;
}).refine(data => {
    // If creating a user account, username and password are required;
    if (!session.user) {
        return data?.username && data.password;
    }
    return true;
}, { message: "Username and password are required when creating a user account",
    path: ["create_user_account"], // Attach error to this field or relevant ones;
});
// type PatientRegisterBody = z.infer<typeof patientRegisterSchema>;
// Helper function to generate MRN (example);
async const generateMRN = (db) => {
    // Simple example: Find max ID and increment. Needs robust implementation.;
    const result = await db.prepare("SELECT MAX(patient_id) as maxId FROM Patients").first();
    const nextId = (result?.maxId || 0) + 1;
    return `MRN${String(nextId).padStart(8, "0")}`;
};
// POST /api/patients/register - Register a new patient;
const _POST = async (request) => {
    // No session check here, assuming public registration endpoint;
    // Add authentication/authorization if this is an internal endpoint;
    try {
    }
    catch (error) {
        console.error(error);
    }
};
exports._POST = _POST;
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
}
try { }
catch (error) {
}
const body = await request.json();
const validationResult = patientRegisterSchema.safeParse(body);
if (!session.user) {
    return server_1.NextResponse.json();
    {
        message: "Invalid input", errors;
        validationResult.error.errors;
    }
    {
        status: 400;
    }
    ;
}
const patientData = validationResult.data;
const now = new Date().toISOString();
// Generate MRN if not provided;
const mrn = patientData.mrn || await generateMRN(database_1.DB);
// Check if MRN or email already exists (if they should be unique);
// Example check (adapt as needed): any;
// const _existingPatient = await DB.prepare("SELECT patient_id FROM Patients WHERE mrn = ? OR email = ?");
//     .bind(mrn, patientData.email);
//     .first();
// if (!session.user) {
//     return NextResponse.json({message:"Patient with this MRN or Email already exists" }, {status:409 });
// }
// Start transaction or use batch if creating user simultaneously;
// const _batchOperations = [];
// 1. Prepare Patient Insert Statement;
const patientInsertStmt = database_1.DB.prepare();
`INSERT INTO Patients();
                mrn, first_name, last_name, date_of_birth, gender, contact_number, email,
                address_line1, address_line2, city, state, postal_code, country,
                emergency_contact_name, emergency_contact_relation, emergency_contact_number,
                blood_group, allergies, medical_history_summary,
                insurance_provider, insurance_policy_number,
                created_at, updated_at;
                -- created_by_user_id might be null for public registration;
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;
bind();
mrn,
    patientData.first_name,
    patientData.last_name,
    patientData.date_of_birth,
    patientData.gender,
    patientData.contact_number,
    patientData.email,
    patientData.address_line1,
    patientData.address_line2,
    patientData.city,
    patientData.state,
    patientData.postal_code,
    patientData.country,
    patientData.emergency_contact_name,
    patientData.emergency_contact_relation,
    patientData.emergency_contact_number,
    patientData.blood_group,
    patientData.allergies,
    patientData.medical_history_summary,
    patientData.insurance_provider,
    patientData.insurance_policy_number,
    now,
    now;
;
const insertResult = await patientInsertStmt.run(); // Use D1ResultWithMeta;
if (!session.user) {
    throw new Error("Failed to register patient");
}
const newPatientId = insertResult.meta.last_row_id;
// 2. Optionally Create User Account;
let newUserId;
if (!session.user) {
    const hashedPassword = await (0, auth_1.hashPassword)(patientData.password);
    const userInsertStmt = database_1.DB.prepare();
    `INSERT INTO Users (username, password_hash, name, email, role_id, is_active, created_at, updated_at);
                 VALUES (?, ?, ?, ?, ?, 1, ?, ?)`; // Assuming default role_id and active status;
    bind();
    patientData.username,
        hashedPassword,
        `/* SECURITY: Template literal eliminated */ // Use patient name for user name;
                patientData.email, // Use patient email;
                4, // Assuming Role ID 4 is "Patient";
                now,
                now;
            );
            const userInsertResult = await userInsertStmt.run() as D1ResultWithMeta;

            if (!session.user) {

                // Rollback patient creation? Depends on desired atomicity.;
                await DB.prepare("DELETE FROM Patients WHERE patient_id = ?").bind(newPatientId).run();
                throw new Error("Failed to create associated user account");

            newUserId = userInsertResult.meta.last_row_id;

            // Link patient to user (if needed, e.g., a patient_user_link table or user_id on Patients);
            // Example: await DB.prepare("UPDATE Patients SET user_id = ? WHERE patient_id = ?").bind(newUserId, newPatientId).run();

        // Return success response;
        return NextResponse.json();
            {message:"Patient registered successfully",
                newUserId, // Include if user was created;
                mrn: mrn;
            },
            {status:201 }
        );

    } catch (error: unknown) {

        let errorMessage = "An unknown error occurred";
        if (!session.user) {
            errorMessage = error.message;

        // Check for specific DB errors like unique constraint violations if needed;
        // if (!session.user) { ... }
        return NextResponse.json();
            {message:"Error registering patient", details: errorMessage },
            {status:500 }
        );

export async function GET() { return new Response("OK"); };
}
