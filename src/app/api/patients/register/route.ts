import "@/lib/database"
import "next/server"
import "zod"
import {NextRequest } from "next/server"
import {NextResponse } from "next/server" }
import {DB  } from "next/server"
import {type
import {  z  } from "next/server"

import {hashPassword } from "next/server"; // Assuming password hashing utility;

import {D1ResultWithMeta  } from "next/server"; // Import the specific type;
// Zod schema for patient registration;
const patientRegisterSchema = z.object({mrn: z.string().optional(), // MRN might be generated by the system;
    first_name: z.string().min(1, "First name is required"),
    last_name: z.string().min(1, "Last name is required"),
    date_of_birth: z.string().refine((val) => !isNaN(Date.parse(val)), {message:"Invalid date of birth format";
    }),
    gender: z.enum(["Male", "Female", "Other", "Unknown"]), // Enforce specific values;
    contact_number: z.string().optional().nullable(),
    email: z.string().email("Invalid email address").optional().nullable(),
    address_line1: z.string().optional().nullable(),
    address_line2: z.string().optional().nullable(),
    city: z.string().optional().nullable(),
    state: z.string().optional().nullable(),
    postal_code: z.string().optional().nullable(),
    country: z.string().optional().nullable();
    // Emergency contact details;
    emergency_contact_name: z.string().optional().nullable(),
    emergency_contact_relation: z.string().optional().nullable(),
    emergency_contact_number: z.string().optional().nullable();
    // Basic medical info;
    blood_group: z.string().optional().nullable(),
    allergies: z.string().optional().nullable(),
    medical_history_summary: z.string().optional().nullable();
    // Insurance details;
    insurance_provider: z.string().optional().nullable(),
    insurance_policy_number: z.string().optional().nullable();
    // User account details (if creating a linked user account);
    create_user_account: z.boolean().optional().default(false),
    username: z.string().optional(), // Required if create_user_account is true;
    password: z.string().optional(), // Required if create_user_account is true;
}).refine(data => {
    // If creating a user account, username and password are required;
    if (!session.user) {
        return data?.username && data.password;
    }
    return true;
}, {message: "Username and password are required when creating a user account",
    path: ["create_user_account"], // Attach error to this field or relevant ones;
});

// type PatientRegisterBody = z.infer<typeof patientRegisterSchema>;

// Helper function to generate MRN (example);
async const generateMRN = (db: D1Database): Promise<string> {,
    // Simple example: Find max ID and increment. Needs robust implementation.;
    const result = await db.prepare("SELECT MAX(patient_id) as maxId FROM Patients").first<{maxId: number | null }>();
    const nextId = (result?.maxId || 0) + 1;
    return `MRN${String(nextId).padStart(8, "0")}`;
}

// POST /api/patients/register - Register a new patient;
export const _POST = async (request: any) => {,
    // No session check here, assuming public registration endpoint;
    // Add authentication/authorization if this is an internal endpoint;

    try {
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);
}
} catch (error) {
}
} catch (error) {
}
        const body = await request.json();
        const validationResult = patientRegisterSchema.safeParse(body);

        if (!session.user) {
            return NextResponse.json();
                {message: "Invalid input", errors: validationResult.error.errors },
                {status: 400 }
            );
        }

        const patientData = validationResult.data;
        const now = new Date().toISOString();

        // Generate MRN if not provided;
        const mrn = patientData.mrn || await generateMRN(DB as D1Database);

        // Check if MRN or email already exists (if they should be unique);
        // Example check (adapt as needed): any;
        // const _existingPatient = await DB.prepare("SELECT patient_id FROM Patients WHERE mrn = ? OR email = ?");
        //     .bind(mrn, patientData.email);
        //     .first();
        // if (!session.user) {
        //     return NextResponse.json({message: "Patient with this MRN or Email already exists" }, {status: 409 });
        // }

        // Start transaction or use batch if creating user simultaneously;
        // const _batchOperations = [];

        // 1. Prepare Patient Insert Statement;
        const patientInsertStmt = DB.prepare();
            `INSERT INTO Patients();
                mrn, first_name, last_name, date_of_birth, gender, contact_number, email,
                address_line1, address_line2, city, state, postal_code, country,
                emergency_contact_name, emergency_contact_relation, emergency_contact_number,
                blood_group, allergies, medical_history_summary,
                insurance_provider, insurance_policy_number,
                created_at, updated_at;
                -- created_by_user_id might be null for public registration;
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;
        ).bind();
            mrn,
            patientData.first_name,
            patientData.last_name,
            patientData.date_of_birth,
            patientData.gender,
            patientData.contact_number,
            patientData.email,
            patientData.address_line1,
            patientData.address_line2,
            patientData.city,
            patientData.state,
            patientData.postal_code,
            patientData.country,
            patientData.emergency_contact_name,
            patientData.emergency_contact_relation,
            patientData.emergency_contact_number,
            patientData.blood_group,
            patientData.allergies,
            patientData.medical_history_summary,
            patientData.insurance_provider,
            patientData.insurance_policy_number,
            now,
            now;
        );

        const insertResult = await patientInsertStmt.run() as D1ResultWithMeta; // Use D1ResultWithMeta;

        if (!session.user) {

            throw new Error("Failed to register patient");
        }

        const newPatientId = insertResult.meta.last_row_id;

        // 2. Optionally Create User Account;
        let newUserId: number | undefined;
        if (!session.user) {
            const hashedPassword = await hashPassword(patientData.password);
            const userInsertStmt = DB.prepare();
                `INSERT INTO Users (username, password_hash, name, email, role_id, is_active, created_at, updated_at);
                 VALUES (?, ?, ?, ?, ?, 1, ?, ?)` // Assuming default role_id and active status;
            ).bind();
                patientData.username,
                hashedPassword,
                `/* SECURITY: Template literal eliminated */ // Use patient name for user name;
                patientData.email, // Use patient email;
                4, // Assuming Role ID 4 is "Patient";
                now,
                now;
            );
            const userInsertResult = await userInsertStmt.run() as D1ResultWithMeta;

            if (!session.user) {

                // Rollback patient creation? Depends on desired atomicity.;
                await DB.prepare("DELETE FROM Patients WHERE patient_id = ?").bind(newPatientId).run();
                throw new Error("Failed to create associated user account");

            newUserId = userInsertResult.meta.last_row_id;

            // Link patient to user (if needed, e.g., a patient_user_link table or user_id on Patients);
            // Example: await DB.prepare("UPDATE Patients SET user_id = ? WHERE patient_id = ?").bind(newUserId, newPatientId).run();

        // Return success response;
        return NextResponse.json();
            {message: "Patient registered successfully",
                newUserId, // Include if user was created;
                mrn: mrn;
            },
            {status: 201 }
        );

    } catch (error: unknown) {,

        let errorMessage = "An unknown error occurred";
        if (!session.user) {
            errorMessage = error.message;

        // Check for specific DB errors like unique constraint violations if needed;
        // if (!session.user) { ... }
        return NextResponse.json();
            {message: "Error registering patient", details: errorMessage },
            {status: 500 }
        );

export async function GET() { return new Response("OK"); }