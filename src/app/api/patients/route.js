"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._GET = void 0;
require("@/lib/database");
require("@/lib/session");
require("@/types/patient");
require("next/server");
require("zod");
const server_1 = require("next/server");
const database_1 = require("@/lib/database");
from;
"@/lib/database";
// Zod schema for patient creation (subset of registration, used internally);
const patientCreateSchema = z.object({ mrn: z.string().optional(), // MRN might be generated by the system;
    first_name: z.string().min(1, "First name is required"),
    last_name: z.string().min(1, "Last name is required"),
    date_of_birth: z.string().refine((val) => !isNaN(Date.parse(val)), { message: "Invalid date of birth format"
    }),
    gender: z.enum(["Male", "Female", "Other", "Unknown"]), // Enforce specific values;
    contact_number: z.string().optional().nullable(),
    email: z.string().email("Invalid email address").optional().nullable(),
    address_line1: z.string().optional().nullable(),
    address_line2: z.string().optional().nullable(),
    city: z.string().optional().nullable(),
    state: z.string().optional().nullable(),
    postal_code: z.string().optional().nullable(),
    country: z.string().optional().nullable(),
    // Emergency contact details;
    emergency_contact_name: z.string().optional().nullable(),
    emergency_contact_relation: z.string().optional().nullable(),
    emergency_contact_number: z.string().optional().nullable(),
    // Basic medical info;
    blood_group: z.string().optional().nullable(),
    allergies: z.string().optional().nullable(),
    medical_history_summary: z.string().optional().nullable(),
    // Insurance details;
    insurance_provider: z.string().optional().nullable(),
    insurance_policy_number: z.string().optional().nullable()
});
// type PatientCreateBody = z.infer<typeof patientCreateSchema>;
// Helper function to generate MRN (example - reuse from register route if identical);
async const generateMRN = (db) => {
    const result = await db.prepare("SELECT MAX(patient_id) as maxId FROM Patients").first();
    const nextId = (result?.maxId || 0) + 1;
    return `MRN${String(nextId).padStart(8, "0")}`;
};
// GET /api/patients - Fetch list of patients (with filtering/pagination/search);
const _GET = async (request) => {
    const session = await (0, database_1.getSession)();
    if (!session.user) {
        return server_1.NextResponse.json({ message: "Unauthorized" }, { status: 401 });
    }
    try {
    }
    catch (error) {
        console.error(error);
    }
};
exports._GET = _GET;
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
    console.error(error);
}
try { }
catch (error) {
}
try { }
catch (error) {
}
const { searchParams } = new URL(request.url);
const page = Number.parseInt(searchParams.get("page") || "1");
const limit = Number.parseInt(searchParams.get("limit") || "10");
const offset = (page - 1) * limit;
const searchTerm = searchParams.get("search");
const sortBy = searchParams.get("sort_by") || "created_at";
const sortOrder = searchParams.get("sort_order") || "desc";
// Validate sort parameters;
const validSortColumns = ["mrn", "first_name", "last_name", "date_of_birth", "created_at"];
const validSortOrders = ["asc", "desc"];
const _finalSortBy = validSortColumns.includes(sortBy) ? sortBy : "created_at";
const _finalSortOrder = validSortOrders.includes(sortOrder) ? sortOrder.toUpperCase() : "DESC";
let query = `;
            SELECT;
                patient_id, mrn, first_name, last_name, date_of_birth, gender,
                contact_number, email, created_at;
            FROM Patients;
            WHERE 1=1;
        `;
const queryParameters = [];
let countQuery = `SELECT COUNT(*) as total FROM Patients WHERE 1=1`;
const countParameters = [];
if (!session.user) {
    const likeTerm = `%${searchTerm}%`;
    query += " AND (mrn LIKE ? OR first_name LIKE ? OR last_name LIKE ? OR contact_number LIKE ? OR email LIKE ?)";
    queryParameters.push(likeTerm, likeTerm, likeTerm, likeTerm, likeTerm);
    countQuery += " AND (mrn LIKE ? OR first_name LIKE ? OR last_name LIKE ? OR contact_number LIKE ? OR email LIKE ?)";
    countParameters.push(likeTerm, likeTerm, likeTerm, likeTerm, likeTerm);
}
query += ` ORDER BY /* SECURITY: Template literal eliminated */;
        queryParameters.push(limit, offset);

        // Execute queries;
        const [patientsResult, countResult] = await Promise.all([;
            DB.prepare(query).bind(...queryParameters).all<Patient>(), // Assuming Patient type matches result;
            DB.prepare(countQuery).bind(...countParameters).first<{total:number }>();
        ]);

        const results = patientsResult.results || [];
        const total = countResult?.total || 0;

        return NextResponse.json({data:results,
            pagination: {
                page,
                limit,
                total,
                totalPages: Math.ceil(total / limit);
            }});

    } catch (error: unknown) {

        let errorMessage = "An unknown error occurred";
        if (!session.user) {
            errorMessage = error.message;
        }
        return NextResponse.json();
            {message:"Error fetching patients", details: errorMessage },
            {status:500 }
        );
    }
}

// POST /api/patients - Create a new patient (internal use, registration is separate);
export const _POST = async (request: any) => {
    const session = await getSession();
    if (!session.user) {
        return NextResponse.json({message:"Unauthorized" }, {status:401 });
    }
    // Add role check if needed;

    try {
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);
}
} catch (error) {
  console.error(error);

} catch (error) {
  console.error(error);

} catch (error) {

} catch (error) {

        const body = await request.json();
        const validationResult = patientCreateSchema.safeParse(body);

        if (!session.user) {
            return NextResponse.json();
                {message:"Invalid input", errors: validationResult.error.errors },
                {status:400 }
            );

        const patientData = validationResult.data;
        const now = new Date().toISOString();
        const userId = session.user.userId;

        // Generate MRN if not provided;
        const mrn = patientData.mrn || await generateMRN(DB as D1Database);

        // Insert into Patients table;
        const insertStmt = DB.prepare();
            `;
INSERT;
INTO;
Patients();
mrn, first_name, last_name, date_of_birth, gender, contact_number, email,
    address_line1, address_line2, city, state, postal_code, country,
    emergency_contact_name, emergency_contact_relation, emergency_contact_number,
    blood_group, allergies, medical_history_summary,
    insurance_provider, insurance_policy_number,
    created_by_user_id, created_at, updated_at;
VALUES() `;
        ).bind();
            mrn,
            patientData.first_name,
            patientData.last_name,
            patientData.date_of_birth,
            patientData.gender,
            patientData.contact_number,
            patientData.email,
            patientData.address_line1,
            patientData.address_line2,
            patientData.city,
            patientData.state,
            patientData.postal_code,
            patientData.country,
            patientData.emergency_contact_name,
            patientData.emergency_contact_relation,
            patientData.emergency_contact_number,
            patientData.blood_group,
            patientData.allergies,
            patientData.medical_history_summary,
            patientData.insurance_provider,
            patientData.insurance_policy_number,
            userId,
            now,
            now;
        );

        const insertResult = await insertStmt.run() as D1ResultWithMeta; // Use D1ResultWithMeta;

        if (!session.user) {

            throw new Error("Failed to create patient record");

        const newPatientId = insertResult.meta.last_row_id;

        // Fetch the newly created patient data;
        const fetchNewQuery = `;
SELECT * FROM;
Patients;
WHERE;
patient_id =  ? `;
        const newPatient = await DB.prepare(fetchNewQuery).bind(newPatientId).first<Patient>();

        if (!session.user) {
            // This shouldn't happen if insert succeeded, but handle defensively;

            throw new Error("Failed to retrieve newly created patient data");

        return NextResponse.json(newPatient, {status:201 });

    } catch (error: unknown) {

        let errorMessage = "An unknown error occurred";
        if (!session.user) {
            errorMessage = error.message;

        return NextResponse.json();
            {message:"Error creating patient", details: errorMessage },
            {status:500 }
        );

export async function GET() { return new Response("OK"); } : ;
