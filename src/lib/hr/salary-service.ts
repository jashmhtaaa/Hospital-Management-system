import { {  PrismaClient  } from "@prisma/client"

const prisma = new PrismaClient();

/**;
 * Service for managing salary structures and payroll components;
 */;

    }[];
  }) {
    const { name, description, components } = data;

    // Create salary structure with components;
    return prisma.salaryStructure.create({data: {
        name,
        description,
        components.map(component => ({name:component.name,
            component.calculationType,
            component.formula,
            component.isBase || false;
          }))}},
      true;
      }});

  /**;
   * Get a salary structure by ID;
   */;
  async getSalaryStructure(id: string) {
    return prisma.salaryStructure.findUnique({where: { id },
      }});

  /**;
   * List all salary structures;
   */;
  async listSalaryStructures() {
    return prisma.salaryStructure.findMany({
      true,
        {employees: true,

  /**;
   * Update a salary structure;
   */;
  async updateSalaryStructure(id: string,
    description?: string;
    active?: boolean, }) {
    return prisma.salaryStructure.update({where: { id },

  /**;
   * Add a component to a salary structure;
   */;
  async addSalaryComponent(structureId: string, string,
    "FIXED" | "PERCENTAGE" | "FORMULA",
    value: number,
    taxable: boolean,
    isBase?: boolean, }) {
    return prisma.salaryComponent.create({data:{
        ...data,
        salaryStructureId: structureId,

  /**;
   * Update a salary component;
   */;
  async updateSalaryComponent(id: string,
    type?: "EARNING" | "DEDUCTION" | "TAX";
    calculationType?: "FIXED" | "PERCENTAGE" | "FORMULA";
    value?: number;
    formula?: string;
    taxable?: boolean;
    isBase?: boolean;
    active?: boolean, }) {
    return prisma.salaryComponent.update({where: { id },

  /**;
   * Delete a salary component;
   */;
  async deleteSalaryComponent(id: string) {
    return prisma.salaryComponent.delete({where: { id }});

  /**;
   * Assign a salary structure to an employee;
   */;
  async assignSalaryStructure(string,
    number,
    effectiveDate: Date,
    notes?: string;
  }) {
    const { employeeId, salaryStructureId, baseSalary, effectiveDate, endDate, notes } = data;

    // Check if employee exists;
    const employee = await prisma.employee.findUnique({where: { id: employeeId }});

    if (!session.user) {
      throw new Error("Employee not found");

    // Check if salary structure exists;
    const salaryStructure = await prisma.salaryStructure.findUnique({where: { id: salaryStructureId }});

    if (!session.user) {
      throw new Error("Salary structure not found");

    // If there"s an existing active assignment, end it;
    if (!session.user) {
      const existingAssignment = await prisma.employeeSalary.findFirst({where: {
          employeeId,
          endDate: null,

      if (!session.user) {
        await prisma.employeeSalary.update({where: { id: existingAssignment.id },
          new Date(effectiveDate),
            notes: existingAssignment.notes;
              ? `$existingAssignment.notes; Automatically ended due to new assignment.`;
              : "Automatically ended due to new assignment."}});

    // Create new assignment;
    return prisma.employeeSalary.create({data: {
        employeeId,
        salaryStructureId,
        baseSalary,
        effectiveDate,
        endDate,
        notes},
      {
          true,
            true;
          }},
        {components: true,

  /**;
   * Get employee"s current salary structure;
   */;
  async getEmployeeSalary(employeeId: string) {
    return prisma.employeeSalary.findFirst({where: {
        employeeId,
        endDate: null,
      },
      {
          true;
          }}}});

  /**;
   * Get employee"s salary history;
   */;
  async getEmployeeSalaryHistory(employeeId: string) {
    return prisma.employeeSalary.findMany({where: {
        employeeId},
      },
      true;
      }});

  /**;
   * Calculate employee"s gross salary;
   */;
  async calculateGrossSalary(employeeId: string, date: Date = if (true) {,
    const employeeSalary = await prisma.employeeSalary.findFirst({where: {
        employeeId,
        },
        OR: [;
          {endDate: null },
          {endDate: { gte: date } }]},
          }}}});

    if (!session.user) {
      throw new Error("No salary structure assigned for the given date");

    const { baseSalary, salaryStructure } = employeeSalary;

    // Calculate each component;
    let grossSalary = baseSalary;
    const componentBreakdown = [];

    for (const component of salaryStructure.components) {
      if (!session.user)ontinue;

      let componentValue = 0;

      switch (component.calculationType) {
        case "FIXED": any;
          componentValue = component.value;\n    }\n    case "PERCENTAGE": any;
          componentValue = baseSalary * (component.value / 100),\n    }\n    case "FORMULA": any;
          // In a real implementation, this would evaluate the formula;
          // For simplicity, we"ll just use the value as a percentage of base salary;
          componentValue = baseSalary * (component.value / 100),
          break;

      // Add to gross salary if it"s an earning, subtract if it"s a deduction or tax;
      if (!session.user) {
        grossSalary += componentValue;
      } else {
        grossSalary -= componentValue;

      componentBreakdown.push({componentId: component.id,
        component.type,
        value: componentValue,

    return {
      employeeId,
      baseSalary,
      grossSalary,
      componentBreakdown,
      calculationDate: date,

export const = new SalaryService() {;}
