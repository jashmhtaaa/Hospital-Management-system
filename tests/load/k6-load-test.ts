/**\n * Enterprise K6 Load Testing Suite - TypeScript Version\n * Hospital Management System\n * \n * Comprehensive load testing framework for healthcare applications with\n * enterprise-grade performance monitoring, healthcare-specific workflows,\n * and advanced resilience testing capabilities.\n * \n * Test Scenarios:\n * - Sustained Load (Normal Operations)\n * - Spike Test (Peak Hours)\n * - Stress Test (System Limits)\n * - Soak Test (Memory Leaks)\n * - Breakpoint Test (Maximum Capacity)\n * - Volume Test (Data Heavy Operations)\n * - Healthcare Workflow Tests (Patient Journey)\n * \n * API Coverage:\n * - Patient Management APIs\n * - Appointment Scheduling APIs\n * - Clinical Documentation APIs\n * - Billing & Revenue Cycle APIs\n * - Pharmacy Management APIs\n * - Laboratory Management APIs\n * - Emergency Department APIs\n * - Reporting & Analytics APIs\n * \n * @version 2.0.0\n * @author HMS Development Team\n * @compliance HIPAA Performance Standards, HL7 FHIR R4, Healthcare Interoperability\n */\n\nimport { check, group, sleep, fail } from 'k6';\nimport http, { RefinedResponse, ResponseType } from 'k6/http';\nimport { Trend, Rate, Counter, Gauge } from 'k6/metrics';\nimport { randomIntBetween, randomItem, randomString } from 'https://jslib.k6.io/k6-utils/1.4.0/index.js';\nimport { uuidv4 } from 'https://jslib.k6.io/k6-utils/1.4.0/index.js';\nimport encoding from 'k6/encoding';\nimport { textSummary } from 'https://jslib.k6.io/k6-summary/0.0.1/index.js';\n\n// Enterprise metrics for healthcare performance monitoring\nconst apiLatency = new Trend('api_latency', true);\nconst dbConnectionTime = new Trend('db_connection_time', true);\nconst authLatency = new Trend('auth_latency', true);\nconst failRate = new Rate('failed_requests');\nconst successRate = new Rate('successful_requests');\nconst apiCalls = new Counter('api_calls');\nconst concurrentUsers = new Gauge('concurrent_users');\nconst memoryUsage = new Gauge('memory_usage_estimate');\nconst cpuUtilization = new Gauge('cpu_utilization_estimate');\n\n// Healthcare-specific metrics\nconst patientRegistrationTime = new Trend('patient_registration_time');\nconst appointmentBookingTime = new Trend('appointment_booking_time');\nconst clinicalDocumentationTime = new Trend('clinical_documentation_time');\nconst billingProcessingTime = new Trend('billing_processing_time');\nconst pharmacyDispensingTime = new Trend('pharmacy_dispensing_time');\nconst emergencyResponseTime = new Trend('emergency_response_time');\nconst reportGenerationTime = new Trend('report_generation_time');\n\n// Type definitions for healthcare domain objects\ninterface Patient {\n  readonly id: string;\n  readonly mrn: string;\n  readonly firstName: string;\n  readonly lastName: string;\n  readonly dateOfBirth: string;\n  readonly gender: 'M' | 'F' | 'O' | 'U';\n  readonly phone?: string;\n  readonly email?: string;\n  readonly insuranceInfo?: InsuranceInfo;\n}\n\ninterface InsuranceInfo {\n  readonly provider: string;\n  readonly policyNumber: string;\n  readonly groupNumber?: string;\n}\n\ninterface Appointment {\n  readonly id: string;\n  readonly patientId: string;\n  readonly providerId: string;\n  readonly startTime: string;\n  readonly endTime: string;\n  readonly type: AppointmentType;\n  readonly status: AppointmentStatus;\n  readonly priority: Priority;\n  readonly notes?: string;\n}\n\ntype AppointmentType = \n  | 'consultation' | 'follow_up' | 'procedure' | 'surgery' \n  | 'diagnostic' | 'emergency' | 'telemedicine';\n\ntype AppointmentStatus = \n  | 'scheduled' | 'confirmed' | 'checked_in' | 'in_progress' \n  | 'completed' | 'cancelled' | 'no_show';\n\ntype Priority = 'low' | 'normal' | 'high' | 'urgent' | 'emergency';\n\ninterface ClinicalNote {\n  readonly id: string;\n  readonly patientId: string;\n  readonly authorId: string;\n  readonly encounterDate: string;\n  readonly noteType: ClinicalNoteType;\n  readonly content: string;\n  readonly diagnosis?: string[];\n  readonly procedures?: string[];\n}\n\ntype ClinicalNoteType = \n  | 'progress_note' | 'consultation_note' | 'discharge_summary' \n  | 'operative_report' | 'radiology_report' | 'pathology_report';\n\ninterface Invoice {\n  readonly id: string;\n  readonly patientId: string;\n  readonly items: readonly BillingItem[];\n  readonly totalAmount: number;\n  readonly status: InvoiceStatus;\n  readonly dueDate: string;\n}\n\ninterface BillingItem {\n  readonly description: string;\n  readonly quantity: number;\n  readonly unitPrice: number;\n  readonly totalPrice: number;\n  readonly cptCode?: string;\n  readonly icd10Code?: string;\n}\n\ntype InvoiceStatus = 'draft' | 'sent' | 'paid' | 'overdue' | 'cancelled';\n\ninterface AuthTokenResponse {\n  readonly access_token: string;\n  readonly token_type: string;\n  readonly expires_in: number;\n  readonly scope: string;\n}\n\ninterface APIResponse<T> {\n  readonly data?: T;\n  readonly message?: string;\n  readonly success: boolean;\n  readonly timestamp: string;\n  readonly total?: number;\n  readonly page?: number;\n  readonly limit?: number;\n}\n\ninterface TestEnvironment {\n  readonly BASE_URL: string;\n  readonly AUTH_URL: string;\n  readonly CLIENT_ID: string;\n  readonly CLIENT_SECRET: string;\n  readonly TEST_ENVIRONMENT: 'development' | 'staging' | 'production';\n  readonly ENABLE_MONITORING: boolean;\n  readonly MONITORING_ENDPOINT?: string;\n}\n\n// Enterprise test configuration with healthcare-specific scenarios\nexport const options = {\n  scenarios: {\n    // Normal hospital operations (8 AM - 6 PM)\n    normal_operations: {\n      executor: 'ramping-vus',\n      startVUs: 10,\n      stages: [\n        { duration: '2m', target: 50 },     // Morning ramp-up\n        { duration: '5m', target: 200 },    // Peak morning hours\n        { duration: '3m', target: 150 },    // Mid-day stabilization\n        { duration: '5m', target: 250 },    // Afternoon peak\n        { duration: '2m', target: 50 },     // Evening wind-down\n        { duration: '1m', target: 0 },      // Night time\n      ],\n      gracefulRampDown: '30s',\n      tags: { scenario: 'normal_operations' },\n    },\n\n    // Emergency department peak hours\n    emergency_peak: {\n      executor: 'ramping-vus',\n      startVUs: 0,\n      stages: [\n        { duration: '1m', target: 30 },     // Regular ED load\n        { duration: '30s', target: 150 },   // Emergency surge\n        { duration: '5m', target: 150 },    // Sustained emergency load\n        { duration: '2m', target: 30 },     // Return to normal\n        { duration: '1m', target: 0 },      // Recovery\n      ],\n      gracefulRampDown: '30s',\n      tags: { scenario: 'emergency_peak' },\n    },\n\n    // Admission/discharge workflows (high-volume)\n    admission_discharge_workflow: {\n      executor: 'ramping-arrival-rate',\n      startRate: 5,\n      timeUnit: '1s',\n      preAllocatedVUs: 100,\n      maxVUs: 500,\n      stages: [\n        { duration: '3m', target: 20 },     // Regular admissions\n        { duration: '5m', target: 50 },     // Peak admission hours\n        { duration: '3m', target: 20 },     // Discharge period\n        { duration: '2m', target: 5 },      // Cleanup\n      ],\n      tags: { scenario: 'admission_discharge' },\n    },\n\n    // Pharmacy operations (medication orders and dispensing)\n    pharmacy_operations: {\n      executor: 'constant-vus',\n      vus: 80,\n      duration: '10m',\n      tags: { scenario: 'pharmacy_operations' },\n    },\n\n    // Laboratory results processing\n    laboratory_processing: {\n      executor: 'ramping-vus',\n      startVUs: 5,\n      stages: [\n        { duration: '2m', target: 40 },     // Morning lab orders\n        { duration: '8m', target: 40 },     // Steady processing\n        { duration: '2m', target: 5 },      // Evening cleanup\n      ],\n      tags: { scenario: 'laboratory_processing' },\n    },\n\n    // Billing and revenue cycle (end-of-day processing)\n    billing_batch_processing: {\n      executor: 'constant-arrival-rate',\n      rate: 30,\n      timeUnit: '1s',\n      duration: '5m',\n      preAllocatedVUs: 50,\n      maxVUs: 200,\n      tags: { scenario: 'billing_batch' },\n    },\n\n    // Stress test (system breaking point)\n    stress_test: {\n      executor: 'ramping-arrival-rate',\n      startRate: 10,\n      timeUnit: '1s',\n      preAllocatedVUs: 200,\n      maxVUs: 1000,\n      stages: [\n        { duration: '3m', target: 100 },    // Warm up\n        { duration: '5m', target: 300 },    // Increase load\n        { duration: '5m', target: 600 },    // High stress\n        { duration: '3m', target: 1000 },   // Breaking point\n        { duration: '2m', target: 100 },    // Recovery\n        { duration: '1m', target: 0 },      // Cool down\n      ],\n      tags: { scenario: 'stress_test' },\n    },\n\n    // Soak test (memory leak detection)\n    soak_test: {\n      executor: 'constant-vus',\n      vus: 100,\n      duration: '1h',\n      tags: { scenario: 'soak_test' },\n    },\n\n    // Spike test (sudden traffic surges)\n    spike_test: {\n      executor: 'ramping-vus',\n      startVUs: 10,\n      stages: [\n        { duration: '1m', target: 10 },     // Baseline\n        { duration: '30s', target: 500 },   // Sudden spike\n        { duration: '2m', target: 500 },    // Maintain spike\n        { duration: '30s', target: 10 },    // Sudden drop\n        { duration: '1m', target: 0 },      // Recovery\n      ],\n      tags: { scenario: 'spike_test' },\n    },\n  },\n  \n  // Healthcare performance thresholds\n  thresholds: {\n    // Overall system performance\n    'http_req_duration': ['p95<1000', 'p99<2000'],\n    'http_req_failed': ['rate<0.005'],  // 0.5% error rate\n    \n    // Critical healthcare workflows\n    'patient_registration_time': ['p95<3000'],      // Patient registration < 3s\n    'appointment_booking_time': ['p95<2000'],       // Appointment booking < 2s\n    'emergency_response_time': ['p95<500'],         // Emergency workflows < 500ms\n    'pharmacy_dispensing_time': ['p95<4000'],       // Pharmacy operations < 4s\n    'clinical_documentation_time': ['p95<5000'],    // Clinical notes < 5s\n    \n    // API-specific thresholds\n    'api_latency{endpoint:patients}': ['p95<800'],\n    'api_latency{endpoint:appointments}': ['p95<1000'],\n    'api_latency{endpoint:clinical}': ['p95<1500'],\n    'api_latency{endpoint:billing}': ['p95<2000'],\n    'api_latency{endpoint:pharmacy}': ['p95<1200'],\n    'api_latency{endpoint:laboratory}': ['p95<1800'],\n    'api_latency{endpoint:emergency}': ['p95<400'],\n    \n    // Scenario-specific thresholds\n    'http_req_duration{scenario:emergency_peak}': ['p95<600'],\n    'http_req_duration{scenario:normal_operations}': ['p95<1200'],\n    'http_req_failed{scenario:emergency_peak}': ['rate<0.001'],\n    \n    // Resource utilization estimates\n    'concurrent_users': ['value<1000'],\n    'memory_usage_estimate': ['value<85'],    // 85% memory utilization\n    'cpu_utilization_estimate': ['value<80'], // 80% CPU utilization\n  },\n  \n  summaryTrendStats: ['min', 'med', 'avg', 'p(90)', 'p(95)', 'p(99)', 'p(99.9)', 'max', 'count'],\n  summaryTimeUnit: 'ms',\n  \n  // Enhanced reporting configuration\n  setupTimeout: '60s',\n  teardownTimeout: '60s',\n  noConnectionReuse: false,\n  userAgent: 'K6-HMS-LoadTest/2.0.0',\n  \n  // External monitoring integration\n  ext: {\n    influxdb: {\n      enabled: true,\n      addr: 'http://localhost:8086',\n      db: 'k6_hms_load_tests',\n      insecureSkipTLSVerify: true,\n    },\n    prometheus: {\n      enabled: true,\n      addr: 'localhost:9090',\n    },\n  },\n};\n\n// Load test environment configuration\nconst ENV: TestEnvironment = JSON.parse(open('./test-env.json') || '{}') as TestEnvironment;\n\n// Configuration with fallbacks\nconst CONFIG = {\n  BASE_URL: ENV.BASE_URL || __ENV.HMS_BASE_URL || 'https://api.hms.health',\n  AUTH_URL: ENV.AUTH_URL || __ENV.HMS_AUTH_URL || 'https://auth.hms.health',\n  CLIENT_ID: ENV.CLIENT_ID || __ENV.HMS_CLIENT_ID || '',\n  CLIENT_SECRET: ENV.CLIENT_SECRET || __ENV.HMS_CLIENT_SECRET || '',\n  TEST_ENVIRONMENT: ENV.TEST_ENVIRONMENT || 'staging',\n  ENABLE_MONITORING: ENV.ENABLE_MONITORING || true,\n  MONITORING_ENDPOINT: ENV.MONITORING_ENDPOINT,\n} as const;\n\n// Validate configuration\nif (!CONFIG.CLIENT_ID || !CONFIG.CLIENT_SECRET) {\n  throw new Error('Missing required authentication credentials');\n}\n\n// Enterprise authentication service\nclass AuthenticationService {\n  private static tokenCache: { token: string; expiresAt: number } | null = null;\n\n  static async getAuthToken(): Promise<string> {\n    // Check if we have a valid cached token\n    if (this.tokenCache && crypto.getRandomValues(new Uint32Array(1))[0] < this.tokenCache.expiresAt) {\n      return this.tokenCache.token;\n    }\n\n    const credentials = `${CONFIG.CLIENT_ID}:${CONFIG.CLIENT_SECRET}`;\n    const encodedCredentials = encoding.b64encode(credentials);\n    \n    const params = {\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Authorization': `Basic ${encodedCredentials}`,\n        'User-Agent': 'HMS-LoadTest/2.0.0',\n      },\n      timeout: '30s',\n    };\n    \n    const data = {\n      grant_type: 'client_credentials',\n      scope: 'api.full_access healthcare.read healthcare.write'\n    };\n\n    const startTime = crypto.getRandomValues(new Uint32Array(1))[0];\n    const response = http.post(`${CONFIG.AUTH_URL}/oauth/token`, data, params);\n    const authDuration = crypto.getRandomValues(new Uint32Array(1))[0] - startTime;\n    \n    authLatency.add(authDuration);\n    \n    const authSuccess = check(response, {\n      'Auth request successful': (r) => r.status === 200,\n      'Auth token present': (r) => r.status === 200 && r.json('access_token') !== undefined,\n      'Auth response time acceptable': () => authDuration < 5000,\n    });\n    \n    if (!authSuccess || response.status !== 200) {\n      failRate.add(1);\n      throw new Error(`Authentication failed: ${response.status} ${response.body}`);\n    }\n    \n    const tokenData = response.json() as AuthTokenResponse;\n    const expiresAt = crypto.getRandomValues(new Uint32Array(1))[0] + (tokenData.expires_in * 1000) - 60000; // 1 minute buffer\n    \n    this.tokenCache = {\n      token: tokenData.access_token,\n      expiresAt\n    };\n    \n    successRate.add(1);\n    return tokenData.access_token;\n  }\n\n  static invalidateToken(): void {\n    this.tokenCache = null;\n  }\n}\n\n// Data cache for realistic testing\ninterface TestDataCache {\n  patients: Patient[];\n  providers: { id: string; name: string; specialty: string }[];\n  appointments: Appointment[];\n  medications: { id: string; name: string; dosage: string }[];\n}\n\nconst testDataCache: TestDataCache = {\n  patients: [],\n  providers: [],\n  appointments: [],\n  medications: []\n};\n\n// Healthcare workflow testing utilities\nclass HealthcareWorkflowTester {\n  private headers: Record<string, string>;\n  \n  constructor(token: string, requestId: string = uuidv4()) {\n    this.headers = {\n      'Authorization': `Bearer ${token}`,\n      'Content-Type': 'application/json',\n      'Accept': 'application/json',\n      'X-Request-ID': requestId,\n      'X-Test-Run': 'k6-load-test',\n      'X-User-Agent': 'HMS-LoadTest/2.0.0',\n    };\n  }\n\n  // Patient management workflows\n  async testPatientRegistrationWorkflow(): Promise<void> {\n    const startTime = crypto.getRandomValues(new Uint32Array(1))[0];\n    \n    group('Patient Registration Workflow', () => {\n      // Step 1: Check patient eligibility\n      const eligibilityCheck = http.get(\n        `${CONFIG.BASE_URL}/api/patients/eligibility-check?insurance=test`, \n        { headers: this.headers }\n      );\n      \n      this.recordMetrics(eligibilityCheck, 'patients', 'eligibility_check');\n      \n      // Step 2: Create new patient\n      const patientData = this.generatePatientData();\n      const createResponse = http.post(\n        `${CONFIG.BASE_URL}/api/patients`,\n        JSON.stringify(patientData),\n        { headers: this.headers }\n      );\n      \n      this.recordMetrics(createResponse, 'patients', 'create');\n      \n      if (createResponse.status === 201) {\n        const patient = createResponse.json() as Patient;\n        testDataCache.patients.push(patient);\n        \n        // Step 3: Upload insurance card\n        const insuranceUpload = http.post(\n          `${CONFIG.BASE_URL}/api/patients/${patient.id}/insurance-documents`,\n          JSON.stringify({ documentType: 'insurance_card', base64Data: 'test_data' }),\n          { headers: this.headers }\n        );\n        \n        this.recordMetrics(insuranceUpload, 'patients', 'insurance_upload');\n        \n        // Step 4: Verify patient information\n        const verifyResponse = http.get(\n          `${CONFIG.BASE_URL}/api/patients/${patient.id}`,\n          { headers: this.headers }\n        );\n        \n        this.recordMetrics(verifyResponse, 'patients', 'verify');\n      }\n    });\n    \n    patientRegistrationTime.add(crypto.getRandomValues(new Uint32Array(1))[0] - startTime);\n  }\n\n  async testAppointmentBookingWorkflow(): Promise<void> {\n    const startTime = crypto.getRandomValues(new Uint32Array(1))[0];\n    \n    group('Appointment Booking Workflow', () => {\n      // Step 1: Search available providers\n      const providerSearch = http.get(\n        `${CONFIG.BASE_URL}/api/providers/search?specialty=cardiology&availability=true`,\n        { headers: this.headers }\n      );\n      \n      this.recordMetrics(providerSearch, 'appointments', 'provider_search');\n      \n      // Step 2: Check provider availability\n      const providerId = `PROV-${randomIntBetween(1000, 9999)}`;\n      const availabilityCheck = http.get(\n        `${CONFIG.BASE_URL}/api/providers/${providerId}/availability?date=${this.getFutureDate(7)}`,\n        { headers: this.headers }\n      );\n      \n      this.recordMetrics(availabilityCheck, 'appointments', 'availability_check');\n      \n      // Step 3: Book appointment\n      const appointmentData = this.generateAppointmentData();\n      const bookingResponse = http.post(\n        `${CONFIG.BASE_URL}/api/appointments`,\n        JSON.stringify(appointmentData),\n        { headers: this.headers }\n      );\n      \n      this.recordMetrics(bookingResponse, 'appointments', 'booking');\n      \n      if (bookingResponse.status === 201) {\n        const appointment = bookingResponse.json() as Appointment;\n        \n        // Step 4: Send appointment confirmation\n        const confirmationResponse = http.post(\n          `${CONFIG.BASE_URL}/api/appointments/${appointment.id}/confirmation`,\n          JSON.stringify({ method: 'email_and_sms' }),\n          { headers: this.headers }\n        );\n        \n        this.recordMetrics(confirmationResponse, 'appointments', 'confirmation');\n      }\n    });\n    \n    appointmentBookingTime.add(crypto.getRandomValues(new Uint32Array(1))[0] - startTime);\n  }\n\n  async testEmergencyWorkflow(): Promise<void> {\n    const startTime = crypto.getRandomValues(new Uint32Array(1))[0];\n    \n    group('Emergency Department Workflow', () => {\n      // Step 1: Emergency registration\n      const emergencyRegistration = http.post(\n        `${CONFIG.BASE_URL}/api/emergency/registration`,\n        JSON.stringify({\n          patientId: this.getRandomPatientId(),\n          chiefComplaint: 'Chest pain',\n          triageLevel: 2,\n          arrivalMethod: 'ambulance'\n        }),\n        { headers: this.headers }\n      );\n      \n      this.recordMetrics(emergencyRegistration, 'emergency', 'registration');\n      \n      if (emergencyRegistration.status === 201) {\n        const encounter = emergencyRegistration.json();\n        \n        // Step 2: Triage assessment\n        const triageAssessment = http.post(\n          `${CONFIG.BASE_URL}/api/emergency/encounters/${encounter.id}/triage`,\n          JSON.stringify({\n            vitalSigns: {\n              bloodPressure: '140/90',\n              heartRate: 110,\n              temperature: 98.6,\n              oxygenSaturation: 97\n            },\n            painScore: 8,\n            triageNotes: 'Acute chest pain, possible MI'\n          }),\n          { headers: this.headers }\n        );\n        \n        this.recordMetrics(triageAssessment, 'emergency', 'triage');\n        \n        // Step 3: Physician assessment\n        const physicianAssessment = http.post(\n          `${CONFIG.BASE_URL}/api/emergency/encounters/${encounter.id}/assessment`,\n          JSON.stringify({\n            assessment: 'Rule out myocardial infarction',\n            plan: 'ECG, troponins, chest X-ray',\n            priority: 'urgent'\n          }),\n          { headers: this.headers }\n        );\n        \n        this.recordMetrics(physicianAssessment, 'emergency', 'assessment');\n      }\n    });\n    \n    emergencyResponseTime.add(crypto.getRandomValues(new Uint32Array(1))[0] - startTime);\n  }\n\n  async testClinicalDocumentationWorkflow(): Promise<void> {\n    const startTime = crypto.getRandomValues(new Uint32Array(1))[0];\n    \n    group('Clinical Documentation Workflow', () => {\n      // Step 1: Create progress note\n      const progressNote = http.post(\n        `${CONFIG.BASE_URL}/api/clinical/notes`,\n        JSON.stringify({\n          patientId: this.getRandomPatientId(),\n          noteType: 'progress_note',\n          content: 'Patient is stable and responding well to treatment.',\n          diagnosis: ['I21.9'], // ICD-10 code for acute MI\n          procedures: ['93010'], // CPT code for ECG\n        }),\n        { headers: this.headers }\n      );\n      \n      this.recordMetrics(progressNote, 'clinical', 'progress_note');\n      \n      // Step 2: Sign the note\n      if (progressNote.status === 201) {\n        const note = progressNote.json();\n        const signNote = http.post(\n          `${CONFIG.BASE_URL}/api/clinical/notes/${note.id}/sign`,\n          JSON.stringify({ signature: 'electronic_signature' }),\n          { headers: this.headers }\n        );\n        \n        this.recordMetrics(signNote, 'clinical', 'sign_note');\n      }\n      \n      // Step 3: Generate clinical summary\n      const clinicalSummary = http.get(\n        `${CONFIG.BASE_URL}/api/clinical/patients/${this.getRandomPatientId()}/summary`,\n        { headers: this.headers }\n      );\n      \n      this.recordMetrics(clinicalSummary, 'clinical', 'summary');\n    });\n    \n    clinicalDocumentationTime.add(crypto.getRandomValues(new Uint32Array(1))[0] - startTime);\n  }\n\n  async testPharmacyWorkflow(): Promise<void> {\n    const startTime = crypto.getRandomValues(new Uint32Array(1))[0];\n    \n    group('Pharmacy Workflow', () => {\n      // Step 1: Create prescription\n      const prescription = http.post(\n        `${CONFIG.BASE_URL}/api/pharmacy/prescriptions`,\n        JSON.stringify({\n          patientId: this.getRandomPatientId(),\n          prescriberId: `PROV-${randomIntBetween(1000, 9999)}`,\n          medications: [{\n            medicationId: `MED-${randomIntBetween(1000, 9999)}`,\n            dosage: '500mg',\n            frequency: 'BID',\n            duration: '30 days',\n            quantity: 60\n          }]\n        }),\n        { headers: this.headers }\n      );\n      \n      this.recordMetrics(prescription, 'pharmacy', 'prescription');\n      \n      if (prescription.status === 201) {\n        const prescriptionData = prescription.json();\n        \n        // Step 2: Check drug interactions\n        const interactionCheck = http.post(\n          `${CONFIG.BASE_URL}/api/pharmacy/interactions/check`,\n          JSON.stringify({\n            patientId: prescriptionData.patientId,\n            newMedications: prescriptionData.medications\n          }),\n          { headers: this.headers }\n        );\n        \n        this.recordMetrics(interactionCheck, 'pharmacy', 'interaction_check');\n        \n        // Step 3: Dispense medication\n        const dispensing = http.post(\n          `${CONFIG.BASE_URL}/api/pharmacy/dispensing`,\n          JSON.stringify({\n            prescriptionId: prescriptionData.id,\n            dispensedBy: 'pharmacist_001',\n            patientCounseled: true\n          }),\n          { headers: this.headers }\n        );\n        \n        this.recordMetrics(dispensing, 'pharmacy', 'dispensing');\n      }\n    });\n    \n    pharmacyDispensingTime.add(crypto.getRandomValues(new Uint32Array(1))[0] - startTime);\n  }\n\n  async testBillingWorkflow(): Promise<void> {\n    const startTime = crypto.getRandomValues(new Uint32Array(1))[0];\n    \n    group('Billing Workflow', () => {\n      // Step 1: Create invoice\n      const invoice = http.post(\n        `${CONFIG.BASE_URL}/api/billing/invoices`,\n        JSON.stringify({\n          patientId: this.getRandomPatientId(),\n          items: [\n            {\n              description: 'Office Visit - Level 4',\n              cptCode: '99214',\n              quantity: 1,\n              unitPrice: 250.00\n            },\n            {\n              description: 'Laboratory Panel',\n              cptCode: '80053',\n              quantity: 1,\n              unitPrice: 125.00\n            }\n          ],\n          insuranceInfo: {\n            provider: 'Blue Cross Blue Shield',\n            policyNumber: 'TEST123456'\n          }\n        }),\n        { headers: this.headers }\n      );\n      \n      this.recordMetrics(invoice, 'billing', 'invoice_creation');\n      \n      if (invoice.status === 201) {\n        const invoiceData = invoice.json();\n        \n        // Step 2: Process insurance claim\n        const insuranceClaim = http.post(\n          `${CONFIG.BASE_URL}/api/billing/claims`,\n          JSON.stringify({\n            invoiceId: invoiceData.id,\n            claimType: 'primary'\n          }),\n          { headers: this.headers }\n        );\n        \n        this.recordMetrics(insuranceClaim, 'billing', 'insurance_claim');\n        \n        // Step 3: Generate patient statement\n        const patientStatement = http.get(\n          `${CONFIG.BASE_URL}/api/billing/invoices/${invoiceData.id}/statement`,\n          { headers: this.headers }\n        );\n        \n        this.recordMetrics(patientStatement, 'billing', 'patient_statement');\n      }\n    });\n    \n    billingProcessingTime.add(crypto.getRandomValues(new Uint32Array(1))[0] - startTime);\n  }\n\n  async testReportingWorkflow(): Promise<void> {\n    const startTime = crypto.getRandomValues(new Uint32Array(1))[0];\n    \n    group('Reporting Workflow', () => {\n      // Step 1: Generate quality metrics report\n      const qualityReport = http.post(\n        `${CONFIG.BASE_URL}/api/reports/quality-metrics`,\n        JSON.stringify({\n          reportType: 'monthly',\n          dateRange: {\n            startDate: this.getPastDate(30),\n            endDate: new Date().toISOString()\n          },\n          metrics: ['patient_satisfaction', 'readmission_rate', 'mortality_rate']\n        }),\n        { headers: this.headers }\n      );\n      \n      this.recordMetrics(qualityReport, 'reports', 'quality_metrics');\n      \n      // Step 2: Generate financial report\n      const financialReport = http.post(\n        `${CONFIG.BASE_URL}/api/reports/financial`,\n        JSON.stringify({\n          reportType: 'revenue_cycle',\n          period: 'monthly'\n        }),\n        { headers: this.headers }\n      );\n      \n      this.recordMetrics(financialReport, 'reports', 'financial');\n      \n      // Step 3: Export report to PDF\n      if (qualityReport.status === 200) {\n        const reportData = qualityReport.json();\n        const pdfExport = http.get(\n          `${CONFIG.BASE_URL}/api/reports/${reportData.id}/export?format=pdf`,\n          { \n            headers: {\n              ...this.headers,\n              'Accept': 'application/pdf'\n            }\n          }\n        );\n        \n        this.recordMetrics(pdfExport, 'reports', 'pdf_export');\n      }\n    });\n    \n    reportGenerationTime.add(crypto.getRandomValues(new Uint32Array(1))[0] - startTime);\n  }\n\n  // Utility methods\n  private recordMetrics(response: RefinedResponse<ResponseType | undefined>, endpoint: string, operation: string): void {\n    apiCalls.add(1);\n    apiLatency.add(response.timings.duration, { endpoint, operation });\n    \n    const success = check(response, {\n      [`${endpoint}:${operation} status acceptable`]: (r) => r.status >= 200 && r.status < 400,\n      [`${endpoint}:${operation} response time acceptable`]: (r) => r.timings.duration < 10000,\n    });\n    \n    if (success) {\n      successRate.add(1);\n    } else {\n      failRate.add(1);\n      console.error(`API Error in ${endpoint}:${operation} - Status: ${response.status}, Body: ${response.body}`);\n    }\n  }\n\n  private generatePatientData(): Partial<Patient> {\n    return {\n      mrn: `MRN-${randomString(8, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')}`,\n      firstName: randomItem(['John', 'Jane', 'Michael', 'Sarah', 'David', 'Emily']),\n      lastName: randomItem(['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia']),\n      dateOfBirth: this.getRandomDateOfBirth(),\n      gender: randomItem(['M', 'F', 'O', 'U']),\n      phone: `555-${randomIntBetween(100, 999)}-${randomIntBetween(1000, 9999)}`,\n      email: `test.${randomString(8)}@example.com`,\n      insuranceInfo: {\n        provider: randomItem(['Blue Cross', 'Aetna', 'Cigna', 'United Healthcare']),\n        policyNumber: randomString(10, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'),\n        groupNumber: randomString(6, '0123456789')\n      }\n    };\n  }\n\n  private generateAppointmentData(): Partial<Appointment> {\n    const startTime = new Date(crypto.getRandomValues(new Uint32Array(1))[0] + randomIntBetween(1, 30) * 24 * 60 * 60 * 1000);\n    const endTime = new Date(startTime.getTime() + 30 * 60 * 1000); // 30 minutes later\n    \n    return {\n      patientId: this.getRandomPatientId(),\n      providerId: `PROV-${randomIntBetween(1000, 9999)}`,\n      startTime: startTime.toISOString(),\n      endTime: endTime.toISOString(),\n      type: randomItem(['consultation', 'follow_up', 'procedure', 'diagnostic']),\n      status: 'scheduled',\n      priority: randomItem(['normal', 'high', 'urgent']),\n      notes: 'Load test appointment'\n    };\n  }\n\n  private getRandomPatientId(): string {\n    if (testDataCache.patients.length > 0) {\n      return randomItem(testDataCache.patients).id;\n    }\n    return `PAT-${randomIntBetween(1000, 9999)}`;\n  }\n\n  private getFutureDate(daysFromNow: number): string {\n    const futureDate = new Date(crypto.getRandomValues(new Uint32Array(1))[0] + daysFromNow * 24 * 60 * 60 * 1000);\n    return futureDate.toISOString().split('T')[0];\n  }\n\n  private getPastDate(daysAgo: number): string {\n    const pastDate = new Date(crypto.getRandomValues(new Uint32Array(1))[0] - daysAgo * 24 * 60 * 60 * 1000);\n    return pastDate.toISOString();\n  }\n\n  private getRandomDateOfBirth(): string {\n    const minAge = 18;\n    const maxAge = 90;\n    const randomAge = randomIntBetween(minAge, maxAge);\n    const birthDate = new Date(crypto.getRandomValues(new Uint32Array(1))[0] - randomAge * 365 * 24 * 60 * 60 * 1000);\n    return birthDate.toISOString().split('T')[0];\n  }\n}\n\n// Setup function executed once per VU\nexport function setup(): { token: string } {\n  console.log('üè• Initializing HMS Load Test Suite...');\n  console.log(`Environment: ${CONFIG.TEST_ENVIRONMENT}`);\n  console.log(`Base URL: ${CONFIG.BASE_URL}`);\n  \n  const token = AuthenticationService.getAuthToken();\n  \n  if (!token) {\n    fail('Failed to obtain authentication token in setup');\n  }\n  \n  // Prefetch test data for realistic workflows\n  const headers = {\n    'Authorization': `Bearer ${token}`,\n    'Content-Type': 'application/json'\n  };\n  \n  try {\n    // Prefetch patients\n    const patientsResponse = http.get(`${CONFIG.BASE_URL}/api/patients?limit=50`, { headers, timeout: '30s' });\n    if (patientsResponse.status === 200) {\n      const patients = patientsResponse.json('data') as Patient[];\n      if (patients && patients.length > 0) {\n        testDataCache.patients.push(...patients.slice(0, 50));\n        console.log(`Prefetched ${testDataCache.patients.length} patient records`);\n      }\n    }\n    \n    // Prefetch providers\n    const providersResponse = http.get(`${CONFIG.BASE_URL}/api/providers?limit=20`, { headers, timeout: '30s' });\n    if (providersResponse.status === 200) {\n      const providers = providersResponse.json('data');\n      if (providers && providers.length > 0) {\n        testDataCache.providers.push(...providers.slice(0, 20));\n        console.log(`Prefetched ${testDataCache.providers.length} provider records`);\n      }\n    }\n    \n  } catch (error) {\n    console.warn('Warning: Failed to prefetch some test data:', error);\n  }\n  \n  console.log('‚úÖ Setup completed successfully');\n  return { token };\n}\n\n// Main test function\nexport default function(data: { token: string }): void {\n  if (!data.token) {\n    fail('No authentication token available');\n    return;\n  }\n  \n  // Update concurrent users metric\n  concurrentUsers.add(1);\n  \n  // Estimate resource utilization (simplified)\n  const estimatedMemoryUsage = Math.min(85, 20 + (concurrentUsers.value * 0.1));\n  const estimatedCpuUsage = Math.min(80, 15 + (concurrentUsers.value * 0.08));\n  memoryUsage.add(estimatedMemoryUsage);\n  cpuUtilization.add(estimatedCpuUsage);\n  \n  const workflow = new HealthcareWorkflowTester(data.token);\n  \n  // Determine test scenario based on VU and iteration\n  const vuId = __VU;\n  const iteration = __ITER;\n  const scenario = __ENV.K6_SCENARIO_NAME || 'default';\n  \n  // Realistic user behavior patterns\n  const userBehaviorPattern = vuId % 10;\n  \n  try {\n    switch (userBehaviorPattern) {\n      case 0:\n      case 1:\n        // 20% - Patient registration and appointment booking\n        workflow.testPatientRegistrationWorkflow();\n        sleep(randomIntBetween(2, 5));\n        workflow.testAppointmentBookingWorkflow();\n        break;\n        \n      case 2:\n      case 3:\n        // 20% - Clinical documentation workflows\n        workflow.testClinicalDocumentationWorkflow();\n        sleep(randomIntBetween(1, 3));\n        workflow.testPharmacyWorkflow();\n        break;\n        \n      case 4:\n        // 10% - Emergency department workflows\n        workflow.testEmergencyWorkflow();\n        break;\n        \n      case 5:\n      case 6:\n        // 20% - Pharmacy and laboratory workflows\n        workflow.testPharmacyWorkflow();\n        sleep(randomIntBetween(1, 2));\n        // Add laboratory workflow here when available\n        break;\n        \n      case 7:\n        // 10% - Billing and revenue cycle\n        workflow.testBillingWorkflow();\n        break;\n        \n      case 8:\n        // 10% - Reporting and analytics\n        workflow.testReportingWorkflow();\n        break;\n        \n      case 9:\n        // 10% - Mixed workflows (heavy users)\n        workflow.testPatientRegistrationWorkflow();\n        sleep(1);\n        workflow.testClinicalDocumentationWorkflow();\n        sleep(1);\n        workflow.testBillingWorkflow();\n        break;\n        \n      default:\n        // Fallback to basic patient workflow\n        workflow.testPatientRegistrationWorkflow();\n        break;\n    }\n    \n  } catch (error) {\n    console.error(`Workflow error in VU ${vuId}, iteration ${iteration}:`, error);\n    failRate.add(1);\n  }\n  \n  // Realistic user think time\n  const thinkTime = scenario === 'emergency_peak' ? \n    randomIntBetween(1, 2) : \n    randomIntBetween(2, 8);\n  \n  sleep(thinkTime);\n}\n\n// Teardown function\nexport function teardown(data: { token: string }): void {\n  console.log('üßπ Cleaning up HMS Load Test Suite...');\n  \n  // Invalidate authentication token\n  AuthenticationService.invalidateToken();\n  \n  // Log final metrics summary\n  console.log('üìä Final Metrics Summary:');\n  console.log(`Total API calls: ${apiCalls.value}`);\n  console.log(`Success rate: ${(successRate.value * 100).toFixed(2)}%`);\n  console.log(`Failure rate: ${(failRate.value * 100).toFixed(2)}%`);\n  \n  if (CONFIG.ENABLE_MONITORING && CONFIG.MONITORING_ENDPOINT) {\n    try {\n      // Send final metrics to monitoring system\n      http.post(CONFIG.MONITORING_ENDPOINT, JSON.stringify({\n        testRun: 'k6-hms-load-test',\n        timestamp: new Date().toISOString(),\n        metrics: {\n          totalCalls: apiCalls.value,\n          successRate: successRate.value,\n          failureRate: failRate.value,\n          avgResponseTime: apiLatency.avg,\n          maxConcurrentUsers: concurrentUsers.max,\n        }\n      }));\n    } catch (error) {\n      console.warn('Failed to send metrics to monitoring system:', error);\n    }\n  }\n  \n  console.log('‚úÖ Teardown completed successfully');\n}\n\n// Custom summary function for enhanced reporting\nexport function handleSummary(data: any) {\n  const summary = textSummary(data, { indent: ' ', enableColors: true });\n  \n  return {\n    'summary.txt': summary,\n    'summary.json': JSON.stringify(data, null, 2),\n    'summary.html': generateHTMLReport(data),\n    stdout: summary,\n  };\n}\n\n// Generate HTML report for stakeholders\nfunction generateHTMLReport(data: any): string {\n  const timestamp = new Date().toISOString();\n  const testDuration = data.state?.testRunDurationMs || 0;\n  \n  return `\n<!DOCTYPE html>\n<html>\n<head>\n    <title>HMS Load Test Report - ${timestamp}</title>\n    <style>\n        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }\n        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .header { border-bottom: 2px solid #007bff; padding-bottom: 10px; margin-bottom: 20px; }\n        .metric-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 20px 0; }\n        .metric-card { background: #f8f9fa; padding: 15px; border-radius: 6px; border-left: 4px solid #007bff; }\n        .metric-title { font-weight: bold; color: #495057; font-size: 14px; }\n        .metric-value { font-size: 24px; font-weight: bold; color: #007bff; margin: 5px 0; }\n        .metric-unit { font-size: 12px; color: #6c757d; }\n        .success { border-left-color: #28a745; }\n        .warning { border-left-color: #ffc107; }\n        .danger { border-left-color: #dc3545; }\n        .threshold-status { padding: 5px 10px; border-radius: 4px; font-size: 12px; font-weight: bold; }\n        .pass { background-color: #d4edda; color: #155724; }\n        .fail { background-color: #f8d7da; color: #721c24; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>üè• Hospital Management System - Load Test Report</h1>\n            <p><strong>Test Date:</strong> ${timestamp}</p>\n            <p><strong>Test Duration:</strong> ${Math.round(testDuration / 1000)} seconds</p>\n            <p><strong>Environment:</strong> ${CONFIG.TEST_ENVIRONMENT}</p>\n        </div>\n        \n        <div class=\"metric-grid\">\n            <div class=\"metric-card success\">\n                <div class=\"metric-title\">Total Requests</div>\n                <div class=\"metric-value\">${data.metrics?.http_reqs?.count || 0}</div>\n            </div>\n            \n            <div class=\"metric-card ${(data.metrics?.http_req_failed?.rate || 0) < 0.01 ? 'success' : 'danger'}\">\n                <div class=\"metric-title\">Success Rate</div>\n                <div class=\"metric-value\">${((1 - (data.metrics?.http_req_failed?.rate || 0)) * 100).toFixed(2)}<span class=\"metric-unit\">%</span></div>\n            </div>\n            \n            <div class=\"metric-card\">\n                <div class=\"metric-title\">Average Response Time</div>\n                <div class=\"metric-value\">${(data.metrics?.http_req_duration?.avg || 0).toFixed(2)}<span class=\"metric-unit\">ms</span></div>\n            </div>\n            \n            <div class=\"metric-card\">\n                <div class=\"metric-title\">95th Percentile</div>\n                <div class=\"metric-value\">${(data.metrics?.http_req_duration?.['p(95)'] || 0).toFixed(2)}<span class=\"metric-unit\">ms</span></div>\n            </div>\n        </div>\n        \n        <h2>Healthcare Workflow Performance</h2>\n        <div class=\"metric-grid\">\n            <div class=\"metric-card\">\n                <div class=\"metric-title\">Patient Registration</div>\n                <div class=\"metric-value\">${(data.metrics?.patient_registration_time?.avg || 0).toFixed(2)}<span class=\"metric-unit\">ms</span></div>\n            </div>\n            \n            <div class=\"metric-card\">\n                <div class=\"metric-title\">Appointment Booking</div>\n                <div class=\"metric-value\">${(data.metrics?.appointment_booking_time?.avg || 0).toFixed(2)}<span class=\"metric-unit\">ms</span></div>\n            </div>\n            \n            <div class=\"metric-card\">\n                <div class=\"metric-title\">Emergency Response</div>\n                <div class=\"metric-value\">${(data.metrics?.emergency_response_time?.avg || 0).toFixed(2)}<span class=\"metric-unit\">ms</span></div>\n            </div>\n            \n            <div class=\"metric-card\">\n                <div class=\"metric-title\">Pharmacy Processing</div>\n                <div class=\"metric-value\">${(data.metrics?.pharmacy_dispensing_time?.avg || 0).toFixed(2)}<span class=\"metric-unit\">ms</span></div>\n            </div>\n        </div>\n        \n        <h2>Performance Thresholds</h2>\n        <div style=\"overflow-x: auto;\">\n            <table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\">\n                <thead>\n                    <tr style=\"background-color: #007bff; color: white;\">\n                        <th style=\"padding: 10px; text-align: left;\">Metric</th>\n                        <th style=\"padding: 10px; text-align: left;\">Threshold</th>\n                        <th style=\"padding: 10px; text-align: left;\">Actual</th>\n                        <th style=\"padding: 10px; text-align: left;\">Status</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    ${generateThresholdRows(data.thresholds || {})}\n                </tbody>\n            </table>\n        </div>\n        \n        <div style=\"margin-top: 30px; padding: 15px; background-color: #e9ecef; border-radius: 6px;\">\n            <h3>Summary</h3>\n            <p>This load test simulated realistic healthcare workflows including patient registration, appointment booking, clinical documentation, pharmacy operations, and billing processes. The test validates that the HMS can handle expected load patterns while maintaining acceptable response times for critical healthcare operations.</p>\n        </div>\n    </div>\n</body>\n</html>\n  `;\n}\n\nfunction generateThresholdRows(thresholds: any): string {\n  return Object.entries(thresholds)\n    .map(([metric, result]: [string, any]) => {\n      const passed = result.ok;\n      const statusClass = passed ? 'pass' : 'fail';\n      const statusText = passed ? 'PASS' : 'FAIL';\n      \n      return `\n        <tr>\n          <td style=\"padding: 10px; border-bottom: 1px solid #dee2e6;\">${metric}</td>\n          <td style=\"padding: 10px; border-bottom: 1px solid #dee2e6;\">${result.condition || 'N/A'}</td>\n          <td style=\"padding: 10px; border-bottom: 1px solid #dee2e6;\">${result.value?.toFixed(2) || 'N/A'}</td>\n          <td style=\"padding: 10px; border-bottom: 1px solid #dee2e6;\">\n            <span class=\"threshold-status ${statusClass}\">${statusText}</span>\n          </td>\n        </tr>\n      `;\n    })\n    .join('');\n}\n\n// Export configuration for external tools\nexport { CONFIG, testDataCache, HealthcareWorkflowTester };\n"
